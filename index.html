<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Game Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            background: #0a0a12;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        /* Mode Selector Screen */
        #mode-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            color: #fff;
        }
        
        #mode-selector h1 {
            font-size: 48px;
            color: #ffcc00;
            text-shadow: 4px 4px 0 #ff6600;
            margin-bottom: 10px;
        }
        
        #mode-selector h2 {
            font-size: 18px;
            color: #888;
            margin-bottom: 40px;
        }
        
        /* Selection sections */
        .selector-section {
            margin-bottom: 30px;
        }
        
        .selector-section h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* Game selector grid */
        .game-grid {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .game-btn {
            background: linear-gradient(180deg, #2a3a2a 0%, #1a2e1a 100%);
            border: 2px solid #4a6a4a;
            border-radius: 8px;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 150px;
        }
        
        .game-btn:hover {
            background: linear-gradient(180deg, #3a4a3a 0%, #2a3e2a 100%);
            border-color: #44ff44;
            transform: translateY(-2px);
        }
        
        .game-btn:active {
            transform: translateY(0);
        }
        
        .game-btn.selected {
            border-color: #44ff44;
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.3);
        }
        
        .game-btn.coming-soon {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .game-btn.coming-soon:hover {
            transform: none;
            border-color: #4a6a4a;
        }
        
        .game-name {
            font-size: 18px;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .game-year {
            font-size: 11px;
            color: #44ff44;
        }
        
        .game-status {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
        }
        
        /* Mode selector grid */
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            max-width: 800px;
        }
        
        .mode-btn {
            background: linear-gradient(180deg, #2a2a4a 0%, #1a1a2e 100%);
            border: 2px solid #4a4a6a;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            min-width: 160px;
        }
        
        .mode-btn:hover {
            background: linear-gradient(180deg, #3a3a5a 0%, #2a2a3e 100%);
            border-color: #ffcc00;
            transform: translateY(-2px);
        }
        
        .mode-btn:active {
            transform: translateY(0);
        }
        
        .mode-btn.selected {
            border-color: #ffcc00;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
        }
        
        .mode-name {
            font-size: 16px;
            color: #fff;
            margin-bottom: 4px;
        }
        
        .mode-res {
            font-size: 12px;
            color: #88ccff;
            margin-bottom: 2px;
        }
        
        .mode-desc {
            font-size: 10px;
            color: #888;
        }
        
        .mode-export {
            font-size: 10px;
            color: #44ff44;
            margin-top: 4px;
        }
        
        #start-btn {
            margin-top: 40px;
            padding: 15px 60px;
            font-size: 24px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(180deg, #ffcc00 0%, #ff9900 100%);
            border: none;
            border-radius: 8px;
            color: #000;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #start-btn:hover {
            background: linear-gradient(180deg, #ffdd33 0%, #ffaa22 100%);
            transform: scale(1.05);
        }
        
        #start-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Game Container */
        #game-container {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            gap: 12px;
        }
        
        #game-container.active {
            display: flex;
        }
        
        #mode-selector.hidden {
            display: none;
        }
        
        canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #controls {
            color: #6a8aaa;
            font-size: 12px;
            text-align: center;
            letter-spacing: 1px;
        }
        
        #controls span {
            color: #aaccff;
            font-weight: bold;
        }
        
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #666;
            font-size: 12px;
        }
        
        #back-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 16px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
        }
        
        #back-btn:hover {
            background: #444;
            color: #fff;
        }
        
        #export-btn {
            position: absolute;
            top: 10px;
            left: 140px;
            padding: 8px 16px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            background: #2a4a2a;
            border: 1px solid #4a8a4a;
            border-radius: 4px;
            color: #8f8;
            cursor: pointer;
        }
        
        #export-btn:hover {
            background: #3a5a3a;
            color: #fff;
            border-color: #6a6;
        }
        
        #export-btn:disabled {
            background: #333;
            border-color: #444;
            color: #666;
            cursor: not-allowed;
        }
        
        /* Loading indicator */
        #loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffcc00;
            font-size: 24px;
        }
        
        #loading.active {
            display: block;
        }
        
        /* Scanline effect (optional) */
        .scanlines {
            position: relative;
        }
        
        .scanlines::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Game & Mode Selector -->
    <div id="mode-selector">
        <h1>RETRO ENGINE</h1>
        
        <!-- Game Selection -->
        <div class="selector-section">
            <h3>Select Game</h3>
            <div class="game-grid">
                <div class="game-btn selected" data-game="pang">
                    <div class="game-name">PANG</div>
                    <div class="game-year">1989</div>
                </div>
                <div class="game-btn coming-soon" data-game="spaceinvaders">
                    <div class="game-name">SPACE INVADERS</div>
                    <div class="game-year">1978</div>
                    <div class="game-status">COMING SOON</div>
                </div>
                <div class="game-btn coming-soon" data-game="breakout">
                    <div class="game-name">BREAKOUT</div>
                    <div class="game-year">1976</div>
                    <div class="game-status">COMING SOON</div>
                </div>
            </div>
        </div>
        
        <!-- Mode Selection -->
        <div class="selector-section">
            <h3>Select Display Mode</h3>
            <div class="mode-grid">
                <div class="mode-btn" data-mode="1bit">
                    <div class="mode-name">1-BIT</div>
                    <div class="mode-res">256 × 192</div>
                    <div class="mode-desc">Monochrome - ZX81 / Mac Classic</div>
                </div>
                
                <div class="mode-btn" data-mode="8bit-basic">
                    <div class="mode-name">8-BIT BASIC</div>
                    <div class="mode-res">256 × 192</div>
                    <div class="mode-desc">ZX Spectrum - Attribute Clash</div>
                </div>
                
                <div class="mode-btn" data-mode="8bit-cpc">
                    <div class="mode-name">8-BIT CPC</div>
                    <div class="mode-res">160 × 200</div>
                    <div class="mode-desc">Amstrad CPC Mode 0 - Software Sprites</div>
                    <div class="mode-export">✓ DSK EXPORTABLE</div>
                </div>
                
                <div class="mode-btn" data-mode="8bit-plus">
                    <div class="mode-name">8-BIT PLUS</div>
                    <div class="mode-res">320 × 200</div>
                    <div class="mode-desc">Generic Enhanced 8-Bit - Rich Colors</div>
                </div>
                
                <div class="mode-btn" data-mode="8bit-gx4000">
                    <div class="mode-name">8-BIT GX4000</div>
                    <div class="mode-res">320 × 200</div>
                    <div class="mode-desc">Amstrad GX4000 - 16 HW Sprites</div>
                    <div class="mode-export">✓ CPR EXPORTABLE</div>
                </div>
                
                <div class="mode-btn selected" data-mode="16bit">
                    <div class="mode-name">16-BIT</div>
                    <div class="mode-res">320 × 224</div>
                    <div class="mode-desc">Megadrive / Arcade - 60 FPS</div>
                </div>
            </div>
        </div>
        
        <button id="start-btn">START GAME</button>
    </div>
    
    <!-- Game Container -->
    <div id="game-container">
        <button id="back-btn">← MODE SELECT</button>
        <button id="export-btn" title="Export to CPCtelera format">⬇ EXPORT CPCtelera</button>
        <div id="mode-indicator"></div>
        <canvas id="game"></canvas>
        <div id="controls">
            <span>←/→</span> or <span>A/D</span> = Move &nbsp;|&nbsp;
            <span>SPACE</span> or <span>Z</span> = Fire &nbsp;|&nbsp;
            <span>P</span> = Pause &nbsp;|&nbsp;
            <span>ESC</span> = Title
        </div>
    </div>
    
    <!-- Loading -->
    <div id="loading">LOADING...</div>

    <script type="module">
        // ====================================================================
        // INLINE ENGINE CODE (for single-file deployment)
        // ====================================================================
        
        // --------------------------------------------------------------------
        // MODES CONFIGURATION
        // --------------------------------------------------------------------
        
        // ====================================================================
        // MODES CONFIGURATION
        // Per RULES documents: Each mode has specific hardware constraints
        // ====================================================================
        
        const MODES = {
            // -----------------------------------------------------------------
            // 1-BIT MODE - Classic Macintosh Style
            // Per RULES_1BIT_MODE.md: Pure black/white, ordered dithering
            // -----------------------------------------------------------------
            '1bit': {
                id: '1bit',
                name: '1-Bit',
                canvas: { width: 256, height: 192 },
                displayScale: 4,
                palette: ['#000000', '#FFFFFF'],
                maxColours: 2,
                spriteSystem: 'software',
                useTilesheet: false,
                spriteSize: { width: 16, height: 16 },
                maxSpritesOnScreen: 16,
                animFramesPerCharacter: 2,
                targetFPS: 25,
                maxBallsOnScreen: 8,
                maxHarpoons: 1,
                maxPowerUps: 2,
                exportable: false,
                // 1-Bit specific rules
                ditherType: 'bayer4x4',     // Per Rule 3: Use 4x4 Bayer ordered dither
                forbidErrorDiffusion: true, // Per Rule 3: NO Floyd-Steinberg
                solidForeground: true       // Per Rule 5: Foreground elements are SOLID
            },
            
            // -----------------------------------------------------------------
            // 8-BIT BASIC - ZX Spectrum Style
            // Per RULES_8BIT_BASIC_MODE.md: 15 colours, attribute clash
            // -----------------------------------------------------------------
            '8bit-basic': {
                id: '8bit-basic',
                name: '8-Bit Basic',
                canvas: { width: 256, height: 192 },
                displayScale: 4,
                maxColours: 15,
                // ZX Spectrum 15 unique colours (8 colours × 2 brightness, minus duplicate black)
                palette: {
                    // Normal brightness
                    BLACK:   '#000000',
                    BLUE:    '#0000D7',
                    RED:     '#D70000',
                    MAGENTA: '#D700D7',
                    GREEN:   '#00D700',
                    CYAN:    '#00D7D7',
                    YELLOW:  '#D7D700',
                    WHITE:   '#D7D7D7',
                    // Bright variants
                    BRIGHT_BLUE:    '#0000FF',
                    BRIGHT_RED:     '#FF0000',
                    BRIGHT_MAGENTA: '#FF00FF',
                    BRIGHT_GREEN:   '#00FF00',
                    BRIGHT_CYAN:    '#00FFFF',
                    BRIGHT_YELLOW:  '#FFFF00',
                    BRIGHT_WHITE:   '#FFFFFF'
                },
                // Flat palette array for colour snapping
                paletteArray: [
                    '#000000', '#0000D7', '#D70000', '#D700D7',
                    '#00D700', '#00D7D7', '#D7D700', '#D7D7D7',
                    '#0000FF', '#FF0000', '#FF00FF',
                    '#00FF00', '#00FFFF', '#FFFF00', '#FFFFFF'
                ],
                // Attribute cell size (8×8 pixels per cell) - Per Rule 2
                attributeCellSize: 8,
                // Each cell can only have 2 colours (INK + PAPER) - Per Rule 2
                coloursPerCell: 2,
                spriteSystem: 'software',
                useTilesheet: false,
                spriteSize: { width: 16, height: 16 },
                maxSpritesOnScreen: 8,      // Per Rule 4: Software sprites only
                animFramesPerCharacter: 4,
                targetFPS: 25,
                maxBallsOnScreen: 12,
                maxHarpoons: 1,
                maxPowerUps: 3,
                exportable: false,
                // Spectrum specific rules
                preferBlackBackground: true,  // Per Rule 5: "Prefer black background"
                monochromeSpritesFast: true,  // Per Rule 4: Monochrome sprites avoid clash
                attributeClash: true          // Per Rule 2: Attribute system in effect
            },
            
            // -----------------------------------------------------------------
            // 8-BIT CPC - Amstrad CPC Classic Style (Mode 0)
            // Per RULES_AMSTRAD_CPC.md & CPCtelera analysis
            // Golden Rule: "If it wouldn't run smoothly on CPC 464 from tape, it's too fancy"
            // -----------------------------------------------------------------
            '8bit-cpc': {
                id: '8bit-cpc',
                name: '8-Bit CPC',
                canvas: { width: 160, height: 200 },  // Mode 0 resolution
                displayScale: 4,
                pixelAspect: 2,              // Mode 0: 2:1 wide pixels
                maxColours: 16,              // 16 simultaneous from 27 available
                totalPalette: 27,            // Hardware has only 27 fixed colors
                colourBits: 0,               // NOT 12-bit - fixed palette only!
                // Full 27-colour CPC hardware palette (firmware order 0-26)
                // Per CPCtelera: 3 levels per RGB channel (0, 0x80, 0xFF)
                hardwarePalette: [
                    '#000000', '#000080', '#0000FF',  // 0-2: Black, Blue, Bright Blue
                    '#800000', '#800080', '#8000FF',  // 3-5: Red, Magenta, Mauve
                    '#FF0000', '#FF0080', '#FF00FF',  // 6-8: Bright Red, Purple, Bright Magenta
                    '#008000', '#008080', '#0080FF',  // 9-11: Green, Cyan, Sky Blue
                    '#808000', '#808080', '#8080FF',  // 12-14: Yellow, White(grey), Pastel Blue
                    '#FF8000', '#FF8080', '#FF80FF',  // 15-17: Orange, Pink, Pastel Magenta
                    '#00FF00', '#00FF80', '#00FFFF',  // 18-20: Bright Green, Sea Green, Bright Cyan
                    '#80FF00', '#80FF80', '#80FFFF',  // 21-23: Lime, Pastel Green, Pastel Cyan
                    '#FFFF00', '#FFFF80', '#FFFFFF'   // 24-26: Bright Yellow, Pastel Yellow, Bright White
                ],
                spriteSystem: 'software',    // NO hardware sprites on CPC!
                useTilesheet: false,
                spriteSize: { width: 16, height: 16 },
                maxSpritesOnScreen: 10,      // CPU-limited: fewer than GX4000
                animFramesPerCharacter: 2,   // RAM constraints: fewer frames
                targetFPS: 25,               // 25fps typical (half of GX4000's 50fps)
                maxBallsOnScreen: 8,         // Fewer balls than GX4000 (CPU limit)
                maxHarpoons: 1,              // Single harpoon only (CPU budget)
                maxPowerUps: 2,              // Fewer power-ups
                exportable: true,            // .DSK export via CPCtelera
                // CPC-specific limitations (vs GX4000)
                noHardwareSprites: true,     // EVERYTHING is software rendered
                noHardwareScroll: true,      // No ASIC smooth scroll
                noDMASound: true,            // AY-3-8912 only (no PCM)
                preferFlatFills: true,       // Avoid dithering (CPU cost)
                noAttributeClash: true,      // Per-pixel color (unlike Spectrum)
                // Z80 CPU budget per frame
                cpuBudgetCycles: 160000,     // 4MHz / 25fps = 160,000 cycles
                // Video memory (same as GX4000 but no ASIC help)
                videoMode: 0,
                bytesPerLine: 80,
                screenSize: 16384,
                // Software sprite rendering is EXPENSIVE
                // Each 16x16 sprite costs ~2000-4000 cycles to draw
                spriteCostCycles: 3000,
                maxSpriteCyclesBudget: 80000 // Half CPU budget for sprites
            },
            
            // -----------------------------------------------------------------
            // 8-BIT PLUS (GENERIC) - Enhanced 8-bit style with rich colors
            // Colorful mode with smooth gradients and detailed backgrounds
            // Not tied to specific hardware - artistic interpretation
            // -----------------------------------------------------------------
            '8bit-plus': {
                id: '8bit-plus',
                name: '8-Bit Plus (Generic)',
                canvas: { width: 320, height: 200 },  // Mode 1 resolution
                displayScale: 3,
                maxColours: 4096,            // Rich color palette
                spriteSystem: 'hardware',    // Hardware-style sprites
                useTilesheet: true,
                spriteSize: { width: 16, height: 16 },
                maxSpritesOnScreen: 16,
                animFramesPerCharacter: 4,
                targetFPS: 50,
                maxBallsOnScreen: 14,
                maxHarpoons: 2,
                maxPowerUps: 4,
                exportable: false,           // Generic mode - not exportable
                // Plus specific rules
                hasHardwareSprites: true,
                spriteColoursPerPalette: 15,
                hardwareScrolling: true,
                backgroundSoftware: true,
                isGenericPlus: true          // Flag for generic Plus mode
            },
            
            // -----------------------------------------------------------------
            // 8-BIT GX4000 - Authentic GX4000 / CPC Plus Style
            // Per RULES_AMSTRAD_CPC.md: Mode 0, Hardware sprites, 4096 colours
            // Golden Rule: "Plus should feel RICHER, not fundamentally different"
            // -----------------------------------------------------------------
            '8bit-gx4000': {
                id: '8bit-gx4000',
                name: '8-Bit GX4000',
                canvas: { width: 160, height: 200 },  // Mode 0 resolution (authentic)
                displayScale: 3,
                pixelAspect: 2,              // Mode 0: 2:1 wide pixels
                maxColours: 4096,            // Per CPCtelera: 12-bit RGB (4 bits/channel)
                onScreenColours: 16,         // Mode 0: 16 simultaneous colors
                spriteSystem: 'hardware',    // Per ASIC: 16 hardware sprites
                useTilesheet: true,
                spriteSize: { width: 16, height: 16 }, // ASIC sprites: 16x16 fixed
                maxSpritesOnScreen: 16,      // ASIC hard limit
                animFramesPerCharacter: 4,
                targetFPS: 50,               // Full 50Hz PAL with hardware sprites
                maxBallsOnScreen: 14,        // 16 - player - harpoon
                maxHarpoons: 2,              // Dual player possible
                maxPowerUps: 4,
                exportable: true,            // .CPR export via CPCtelera
                // GX4000/Plus specific per CPCtelera analysis
                hasHardwareSprites: true,    // 16 ASIC sprites, independent of background
                spriteColoursPerPalette: 15, // 15 + transparent per sprite palette
                hardwareScrolling: true,     // ASIC smooth pixel scrolling
                backgroundSoftware: true,    // Background still uses CPU
                compatibleWithCPC: true,     // Games can fallback to CPC 6128
                isGX4000: true,              // Flag for authentic GX4000 mode
                // Hardware reference from CPCtelera
                videoMode: 0,                // CPC Mode 0
                bytesPerLine: 80,            // 80 bytes per scanline (all modes)
                screenSize: 16384,           // 16KB video memory
                // Color encoding
                colourBits: 12,              // 4 bits per R/G/B channel
                colourLevels: 16             // 16 levels per channel (0-15)
            },
            
            // -----------------------------------------------------------------
            // 16-BIT - Mega Drive / Genesis & Neo Geo Style
            // Per RULES_16BIT_MODE.md: Cross-platform portable design
            // Golden Rule: "Design like you don't know which 16-bit machine you're shipping on"
            // -----------------------------------------------------------------
            '16bit': {
                id: '16bit',
                name: '16-Bit',
                canvas: { width: 320, height: 224 },   // Per Rule 1: Fixed, no scaling
                displayScale: 3,
                maxColours: 512,                        // Per Rule 2: 9-bit RGB (8 levels per channel)
                maxOnScreenColours: 64,                 // Per Rule 2: 4 palettes × 16 colours
                palettesCount: 4,                       // Per Rule 2: 4 fixed palettes
                coloursPerPalette: 16,                  // Per Rule 2: 16 colours each
                spriteSystem: 'hardware',
                useTilesheet: true,
                tileSize: 8,                            // Per Rule 3: 8×8 base tiles
                spriteSize: { width: 16, height: 16 },  // Per Rule 4: Built from 16×16 blocks
                maxSpritesOnScreen: 80,                 // Per Rule 4: Portable limit (MD)
                maxSpritesPerScanline: 20,              // Per Rule 4: Portable limit (MD)
                animFramesPerCharacter: 8,
                targetFPS: 60,                          // Per Rule 1: NTSC standard
                maxBallsOnScreen: 24,
                maxHarpoons: 2,
                maxPowerUps: 6,
                exportable: false,
                // 16-Bit specific rules per RULES_16BIT_MODE.md
                noTrueAlpha: true,                      // Per Rule 3: No true alpha blending
                shadowsAsDuplicates: true,              // Per Rule 3: Shadows as darkened sprites
                orderedDitherOnly: true,                // Per Rule 7: Ordered dithering only (if any)
                noPhotographicGradients: true,          // Per Rule 7: No photographic gradients
                paletteFixedPerLevel: true,             // Per Rule 2: Changes only between scenes
                hudSafeMargin: 8,                       // Per Rule 1: CRT overscan safety
                hudMaxColours: 4                        // Per Rule 2: UI uses max 4 colours
            }
        };
        
        // --------------------------------------------------------------------
        // SPRITE MANAGER
        // --------------------------------------------------------------------
        
        class SpriteManager {
            constructor(mode) {
                this.mode = mode;
                this.cache = new Map();
            }
            
            async loadAll(definitions) {
                for (const [name, def] of Object.entries(definitions)) {
                    await this.loadSprite(name, def);
                }
            }
            
            async loadSprite(name, def) {
                try {
                    let sprite;
                    if (this.mode.useTilesheet && def.tilesheet?.[this.mode.id]) {
                        sprite = await this.loadTilesheet(def.tilesheet[this.mode.id]);
                    } else if (def.software?.[this.mode.id]) {
                        sprite = await this.loadSoftware(def.software[this.mode.id]);
                    } else {
                        sprite = this.createPlaceholder();
                    }
                    this.cache.set(name, sprite);
                } catch (e) {
                    this.cache.set(name, this.createPlaceholder());
                }
            }
            
            async loadTilesheet(config) {
                const img = await this.loadImage(config.src);
                return {
                    type: 'tilesheet',
                    image: img,
                    tileWidth: config.tileWidth || 16,
                    tileHeight: config.tileHeight || 16,
                    animations: config.animations || {},
                    getAnimationFrame(anim, idx) {
                        const a = this.animations[anim];
                        if (!a) return { sx: 0, sy: 0, sw: this.tileWidth, sh: this.tileHeight };
                        const frame = a.frames[idx % a.frames.length];
                        return {
                            sx: frame * this.tileWidth,
                            sy: (a.row || 0) * this.tileHeight,
                            sw: this.tileWidth,
                            sh: this.tileHeight
                        };
                    }
                };
            }
            
            async loadSoftware(config) {
                const animations = {};
                for (const [name, files] of Object.entries(config)) {
                    if (Array.isArray(files)) {
                        animations[name] = await Promise.all(files.map(f => this.loadImage(f)));
                    }
                }
                return {
                    type: 'software',
                    animations,
                    getAnimationFrame(anim, idx) {
                        const frames = this.animations[anim];
                        if (!frames?.length) return null;
                        return frames[idx % frames.length];
                    }
                };
            }
            
            createPlaceholder() {
                return { type: 'placeholder' };
            }
            
            loadImage(src) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject();
                    img.src = src;
                });
            }
            
            get(name) { return this.cache.get(name); }
        }
        
        // --------------------------------------------------------------------
        // RENDERER
        // --------------------------------------------------------------------
        
        class Renderer {
            constructor(canvas, mode) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.mode = mode;
                this.ctx.imageSmoothingEnabled = false;
                canvas.width = mode.canvas.width;
                canvas.height = mode.canvas.height;
                
                // Pre-create dither pattern for 1-bit mode overlays
                if (mode.id === '1bit') {
                    this.ditherPattern = this.createDitherPattern();
                }
            }
            
            // Create a 50% checkerboard dither pattern
            createDitherPattern() {
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 2;
                patternCanvas.height = 2;
                const pCtx = patternCanvas.getContext('2d');
                pCtx.fillStyle = '#000000';
                pCtx.fillRect(0, 0, 2, 2);
                pCtx.fillStyle = '#FFFFFF';
                pCtx.fillRect(0, 0, 1, 1);
                pCtx.fillRect(1, 1, 1, 1);
                return this.ctx.createPattern(patternCanvas, 'repeat');
            }
            
            // Parse any colour to RGB
            parseColourToRGB(colour) {
                let r = 0, g = 0, b = 0;
                
                if (colour.startsWith('#')) {
                    const hex = colour.slice(1);
                    if (hex.length === 3) {
                        r = parseInt(hex[0] + hex[0], 16);
                        g = parseInt(hex[1] + hex[1], 16);
                        b = parseInt(hex[2] + hex[2], 16);
                    } else {
                        r = parseInt(hex.slice(0, 2), 16);
                        g = parseInt(hex.slice(2, 4), 16);
                        b = parseInt(hex.slice(4, 6), 16);
                    }
                } else if (colour.startsWith('rgba') || colour.startsWith('rgb')) {
                    const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                    if (match) {
                        r = parseInt(match[1]);
                        g = parseInt(match[2]);
                        b = parseInt(match[3]);
                    }
                }
                
                return { r, g, b };
            }
            
            // Snap a colour to the nearest ZX Spectrum palette colour
            // Per RULES_8BIT_BASIC_MODE.md Rule 1
            snapToSpectrumPalette(colour) {
                const { r, g, b } = this.parseColourToRGB(colour);
                const palette = this.mode.paletteArray;
                
                let bestMatch = palette[0];
                let bestDist = Infinity;
                
                for (const palColour of palette) {
                    const pal = this.parseColourToRGB(palColour);
                    // Weighted Euclidean distance (human eye more sensitive to green)
                    const dist = Math.sqrt(
                        0.3 * (r - pal.r) ** 2 +
                        0.59 * (g - pal.g) ** 2 +
                        0.11 * (b - pal.b) ** 2
                    );
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestMatch = palColour;
                    }
                }
                
                return bestMatch;
            }
            
            // Snap a colour to the nearest CPC 27-colour palette
            // Per RULES_8BIT_CPC_MODE.md Rule 2
            snapToCPCPalette(colour) {
                const { r, g, b } = this.parseColourToRGB(colour);
                const palette = this.mode.hardwarePalette || [
                    '#000000', '#000080', '#0000FF', '#800000', '#800080', '#8000FF',
                    '#FF0000', '#FF0080', '#FF00FF', '#008000', '#008080', '#0080FF',
                    '#808000', '#808080', '#8080FF', '#FF8000', '#FF8080', '#FF80FF',
                    '#00FF00', '#00FF80', '#00FFFF', '#80FF00', '#80FF80', '#80FFFF',
                    '#FFFF00', '#FFFF80', '#FFFFFF'
                ];
                
                let bestMatch = palette[0];
                let bestDist = Infinity;
                
                for (const palColour of palette) {
                    const pal = this.parseColourToRGB(palColour);
                    const dist = Math.sqrt(
                        (r - pal.r) ** 2 +
                        (g - pal.g) ** 2 +
                        (b - pal.b) ** 2
                    );
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestMatch = palColour;
                    }
                }
                
                return bestMatch;
            }
            
            // Snap a colour to the 4096-colour Plus palette (12-bit RGB)
            // Per RULES_8BIT_PLUS_MODE.md Rule 4
            snapToPlusPalette(colour) {
                const { r, g, b } = this.parseColourToRGB(colour);
                
                // Snap to 4-bit per channel (16 levels)
                const r4 = Math.round(r / 255 * 15);
                const g4 = Math.round(g / 255 * 15);
                const b4 = Math.round(b / 255 * 15);
                
                // Convert back to 8-bit for display
                const r8 = Math.round(r4 * 255 / 15);
                const g8 = Math.round(g4 * 255 / 15);
                const b8 = Math.round(b4 * 255 / 15);
                
                return `#${r8.toString(16).padStart(2,'0')}${g8.toString(16).padStart(2,'0')}${b8.toString(16).padStart(2,'0')}`;
            }
            
            // Snap a colour to the 512-colour Mega Drive palette (9-bit RGB)
            // Per RULES_16BIT_MODE.md Rule 2: 3 bits per channel (8 levels each)
            snapTo16BitPalette(colour) {
                const { r, g, b } = this.parseColourToRGB(colour);
                
                // Snap to 3-bit per channel (8 levels: 0-7)
                const r3 = Math.round(r / 255 * 7);
                const g3 = Math.round(g / 255 * 7);
                const b3 = Math.round(b / 255 * 7);
                
                // Convert back to 8-bit for display
                const r8 = Math.round(r3 * 255 / 7);
                const g8 = Math.round(g3 * 255 / 7);
                const b8 = Math.round(b3 * 255 / 7);
                
                return `#${r8.toString(16).padStart(2,'0')}${g8.toString(16).padStart(2,'0')}${b8.toString(16).padStart(2,'0')}`;
            }
            
            // Map colour to mode palette
            // hint: 'background' forces black, 'foreground' forces white/bright, 'auto' uses luminance
            // Per respective RULES documents for each mode
            mapColour(colour, hint = 'auto') {
                // =============================================================
                // 1-BIT MODE - Per RULES_1BIT_MODE.md
                // Pure black or white only, no greys, no colours
                // =============================================================
                if (this.mode.id === '1bit') {
                    // Semantic hints override luminance calculation
                    if (hint === 'background') return '#000000';
                    if (hint === 'foreground') return '#FFFFFF';
                    
                    // Check for semi-transparent colours (used for overlays)
                    if (colour.startsWith('rgba')) {
                        const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)/);
                        if (match) {
                            const alpha = parseFloat(match[4]);
                            // Semi-transparent = use dither pattern (handled separately)
                            if (alpha > 0.2 && alpha < 0.9) {
                                return 'dither';
                            }
                            // Very transparent = black (invisible)
                            if (alpha <= 0.2) return '#000000';
                        }
                    }
                    
                    // Parse colour to RGB for luminance calculation
                    const { r, g, b } = this.parseColourToRGB(colour);
                    
                    // Calculate luminance (perceived brightness)
                    const luminance = (0.299 * r + 0.587 * g + 0.114 * b);
                    
                    // Threshold at 128 (middle grey)
                    return luminance > 128 ? '#FFFFFF' : '#000000';
                }
                
                // =============================================================
                // ZX SPECTRUM (8bit-basic) - Per RULES_8BIT_BASIC_MODE.md
                // Snap to 15-colour palette
                // =============================================================
                if (this.mode.id === '8bit-basic') {
                    // Handle semi-transparent colours
                    if (colour.startsWith('rgba')) {
                        const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)/);
                        if (match) {
                            const alpha = parseFloat(match[4]);
                            // Very transparent = black (invisible)
                            if (alpha <= 0.3) return '#000000';
                            // Otherwise use the RGB values
                            colour = `rgb(${match[1]}, ${match[2]}, ${match[3]})`;
                        }
                    }
                    
                    // Snap to nearest Spectrum colour
                    return this.snapToSpectrumPalette(colour);
                }
                
                // =============================================================
                // AMSTRAD CPC (8bit-cpc) - Per RULES_8BIT_CPC_MODE.md
                // Snap to 27-colour hardware palette
                // =============================================================
                if (this.mode.id === '8bit-cpc') {
                    // Handle semi-transparent colours
                    if (colour.startsWith('rgba')) {
                        const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)/);
                        if (match) {
                            const alpha = parseFloat(match[4]);
                            if (alpha <= 0.3) return '#000000';
                            colour = `rgb(${match[1]}, ${match[2]}, ${match[3]})`;
                        }
                    }
                    
                    // Snap to nearest CPC hardware colour
                    return this.snapToCPCPalette(colour);
                }
                
                // =============================================================
                // CPC PLUS (8bit-plus) - Per RULES_8BIT_PLUS_MODE.md
                // Snap to 4096-colour palette (12-bit RGB)
                // =============================================================
                if (this.mode.id === '8bit-plus') {
                    // Handle semi-transparent colours
                    if (colour.startsWith('rgba')) {
                        const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)/);
                        if (match) {
                            const alpha = parseFloat(match[4]);
                            if (alpha <= 0.3) return '#000000';
                            colour = `rgb(${match[1]}, ${match[2]}, ${match[3]})`;
                        }
                    }
                    
                    // Snap to nearest Plus colour (12-bit)
                    return this.snapToPlusPalette(colour);
                }
                
                // =============================================================
                // 16-BIT MODE - Per RULES_16BIT_MODE.md
                // Snap to 512-colour palette (9-bit RGB)
                // No true alpha blending allowed
                // =============================================================
                if (this.mode.id === '16bit') {
                    // Handle semi-transparent colours - 16-bit has NO true alpha
                    // Per Rule 3: "No true alpha blending"
                    if (colour.startsWith('rgba')) {
                        const match = colour.match(/rgba?\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)/);
                        if (match) {
                            const alpha = parseFloat(match[4]);
                            // Very transparent = treat as transparent (black)
                            if (alpha <= 0.3) return '#000000';
                            // Otherwise use the RGB values directly (no alpha)
                            colour = `rgb(${match[1]}, ${match[2]}, ${match[3]})`;
                        }
                    }
                    
                    // Snap to nearest MD/Neo Geo colour (9-bit)
                    return this.snapTo16BitPalette(colour);
                }
                
                // For any other modes, return original
                return colour;
            }
            
            clear(colour) {
                // Clear is always a background operation in 1-bit mode
                this.ctx.fillStyle = this.mapColour(colour, 'background');
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawSprite(sprite, anim, frameIdx, x, y, opts = {}) {
                if (!sprite || sprite.type === 'placeholder') return;
                
                this.ctx.save();
                
                if (sprite.type === 'tilesheet') {
                    const f = sprite.getAnimationFrame(anim, frameIdx);
                    if (opts.flipX) {
                        this.ctx.translate(x + f.sw, y);
                        this.ctx.scale(-1, 1);
                        this.ctx.drawImage(sprite.image, f.sx, f.sy, f.sw, f.sh, 0, 0, f.sw, f.sh);
                    } else {
                        this.ctx.drawImage(sprite.image, f.sx, f.sy, f.sw, f.sh, x, y, f.sw, f.sh);
                    }
                } else {
                    const img = sprite.getAnimationFrame(anim, frameIdx);
                    if (img) {
                        if (opts.flipX) {
                            this.ctx.translate(x + img.width, y);
                            this.ctx.scale(-1, 1);
                            this.ctx.drawImage(img, 0, 0);
                        } else {
                            this.ctx.drawImage(img, x, y);
                        }
                    }
                }
                
                this.ctx.restore();
            }
            
            // hint: 'background', 'foreground', 'border', or 'auto'
            drawRect(x, y, w, h, colour, hint = 'auto') {
                const mappedColour = this.mapColour(colour, hint);
                
                // Handle dithering for semi-transparent overlays
                if (mappedColour === 'dither' && this.ditherPattern) {
                    this.ctx.fillStyle = this.ditherPattern;
                } else {
                    this.ctx.fillStyle = mappedColour;
                }
                this.ctx.fillRect(x, y, w, h);
            }
            
            // Circles are typically foreground elements (balls, etc)
            drawCircle(x, y, r, colour, hint = 'foreground') {
                this.ctx.fillStyle = this.mapColour(colour, hint);
                this.ctx.beginPath();
                this.ctx.arc(x, y, r, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawText(text, x, y, opts = {}) {
                // Text is foreground by default
                this.ctx.fillStyle = this.mapColour(opts.colour || '#fff', 'foreground');
                this.ctx.font = opts.font || '8px monospace';
                this.ctx.textAlign = opts.align || 'left';
                this.ctx.textBaseline = opts.baseline || 'top';
                this.ctx.fillText(text, x, y);
            }
            
            // Draw a background image, scaled to fit the target area
            drawBackgroundImage(img, x, y, width, height) {
                if (!img || !img.complete) return;
                
                // For 1-bit mode, the image is already dithered, just draw it
                // Scale image to fit the playfield area
                this.ctx.drawImage(img, 
                    0, 0, img.width, img.height,  // Source rect (full image)
                    x, y, width, height            // Dest rect (playfield)
                );
            }
            
            // ================================================================
            // SOFTWARE BACKGROUND RENDERING
            // For 1-bit and Spectrum modes - draws simple geometric shapes
            // with ordered dithering for authentic retro look
            // ================================================================
            
            // 4x4 Bayer dithering matrix (normalized 0-15)
            static BAYER_4X4 = [
                [0,  8,  2, 10],
                [12, 4, 14,  6],
                [3, 11,  1,  9],
                [15, 7, 13,  5]
            ];
            
            // Check if a pixel should be "on" based on dither level
            shouldDitherPixel(x, y, ditherLevel) {
                // ditherLevel: 0 = all black, 1 = all white/cyan
                const threshold = Renderer.BAYER_4X4[y % 4][x % 4] / 16;
                return ditherLevel > threshold;
            }
            
            // Draw a software-defined background
            // bgDef: { elements: [...] } - array of shape definitions
            // bounds: { x, y, width, height } - playfield bounds
            // inkColour: colour for filled pixels (white for 1-bit, white for Spectrum)
            // paperColour: background colour (black for 1-bit, blue for Spectrum)
            drawSoftwareBackground(bgDef, bounds, inkColour, paperColour = '#000000') {
                if (!bgDef || !bgDef.elements) return;
                
                const { x: bx, y: by, width: bw, height: bh } = bounds;
                
                // Create an offscreen canvas for pixel-accurate dithering
                const offscreen = document.createElement('canvas');
                offscreen.width = bw;
                offscreen.height = bh;
                const octx = offscreen.getContext('2d');
                
                // Fill with paper colour (background)
                octx.fillStyle = paperColour;
                octx.fillRect(0, 0, bw, bh);
                
                // Get image data for pixel manipulation
                const imageData = octx.getImageData(0, 0, bw, bh);
                const data = imageData.data;
                
                // Parse ink colour to RGB
                const ink = this.parseColourToRGB(inkColour);
                
                // Process each element
                for (const elem of bgDef.elements) {
                    const dither = elem.dither !== undefined ? elem.dither : 1.0;
                    
                    if (elem.type === 'rect') {
                        this.drawSoftwareRect(data, bw, bh, elem, dither, ink);
                    } else if (elem.type === 'polygon') {
                        this.drawSoftwarePolygon(data, bw, bh, elem, dither, ink);
                    } else if (elem.type === 'circle') {
                        this.drawSoftwareCircle(data, bw, bh, elem, dither, ink);
                    }
                }
                
                // Put the image data back
                octx.putImageData(imageData, 0, 0);
                
                // Draw the offscreen canvas to the main canvas
                this.ctx.drawImage(offscreen, bx, by);
            }
            
            // Draw a dithered rectangle
            drawSoftwareRect(data, w, h, elem, dither, ink) {
                const x1 = Math.floor(elem.x * w);
                const y1 = Math.floor(elem.y * h);
                const x2 = Math.floor((elem.x + elem.width) * w);
                const y2 = Math.floor((elem.y + elem.height) * h);
                
                for (let y = y1; y < y2 && y < h; y++) {
                    for (let x = x1; x < x2 && x < w; x++) {
                        if (x >= 0 && y >= 0 && this.shouldDitherPixel(x, y, dither)) {
                            const idx = (y * w + x) * 4;
                            data[idx] = ink.r;
                            data[idx + 1] = ink.g;
                            data[idx + 2] = ink.b;
                            data[idx + 3] = 255;
                        }
                    }
                }
            }
            
            // Draw a dithered circle
            drawSoftwareCircle(data, w, h, elem, dither, ink) {
                const cx = Math.floor(elem.x * w);
                const cy = Math.floor(elem.y * h);
                const r = Math.floor(elem.radius * Math.min(w, h));
                
                for (let y = cy - r; y <= cy + r; y++) {
                    for (let x = cx - r; x <= cx + r; x++) {
                        if (x >= 0 && x < w && y >= 0 && y < h) {
                            const dx = x - cx;
                            const dy = y - cy;
                            if (dx * dx + dy * dy <= r * r) {
                                if (this.shouldDitherPixel(x, y, dither)) {
                                    const idx = (y * w + x) * 4;
                                    data[idx] = ink.r;
                                    data[idx + 1] = ink.g;
                                    data[idx + 2] = ink.b;
                                    data[idx + 3] = 255;
                                }
                            }
                        }
                    }
                }
            }
            
            // Draw a dithered polygon using scanline fill
            drawSoftwarePolygon(data, w, h, elem, dither, ink) {
                // Convert normalized points to pixel coordinates
                const points = elem.points.map(p => ({
                    x: Math.floor(p.x * w),
                    y: Math.floor(p.y * h)
                }));
                
                if (points.length < 3) return;
                
                // Find bounding box
                let minY = h, maxY = 0;
                for (const p of points) {
                    minY = Math.min(minY, p.y);
                    maxY = Math.max(maxY, p.y);
                }
                
                // Scanline fill algorithm
                for (let y = minY; y <= maxY && y < h; y++) {
                    if (y < 0) continue;
                    
                    // Find intersections with polygon edges
                    const intersections = [];
                    for (let i = 0; i < points.length; i++) {
                        const p1 = points[i];
                        const p2 = points[(i + 1) % points.length];
                        
                        if ((p1.y <= y && p2.y > y) || (p2.y <= y && p1.y > y)) {
                            const x = p1.x + (y - p1.y) / (p2.y - p1.y) * (p2.x - p1.x);
                            intersections.push(Math.floor(x));
                        }
                    }
                    
                    // Sort intersections
                    intersections.sort((a, b) => a - b);
                    
                    // Fill between pairs
                    for (let i = 0; i < intersections.length - 1; i += 2) {
                        const x1 = Math.max(0, intersections[i]);
                        const x2 = Math.min(w - 1, intersections[i + 1]);
                        
                        for (let x = x1; x <= x2; x++) {
                            if (this.shouldDitherPixel(x, y, dither)) {
                                const idx = (y * w + x) * 4;
                                data[idx] = ink.r;
                                data[idx + 1] = ink.g;
                                data[idx + 2] = ink.b;
                                data[idx + 3] = 255;
                            }
                        }
                    }
                }
            }
        }
        
        // --------------------------------------------------------------------
        // INPUT
        // --------------------------------------------------------------------
        
        class Input {
            constructor() {
                this.keys = {};
                this.actions = {
                    left: ['ArrowLeft', 'KeyA'],
                    right: ['ArrowRight', 'KeyD'],
                    fire: ['Space', 'KeyZ', 'KeyK'],
                    pause: ['KeyP']
                };
                this.onKeyDown = null;
                
                window.addEventListener('keydown', e => {
                    this.keys[e.code] = true;
                    if (this.onKeyDown) this.onKeyDown(e.code);
                    if (['Space', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
                window.addEventListener('keyup', e => this.keys[e.code] = false);
                window.addEventListener('blur', () => this.keys = {});
            }
            
            isDown(action) {
                return this.actions[action]?.some(k => this.keys[k]) || false;
            }
            
            update() {}
        }
        
        // --------------------------------------------------------------------
        // AUDIO
        // --------------------------------------------------------------------
        
        class Audio {
            constructor() {
                this.unlocked = false;
            }
            unlock() { this.unlocked = true; }
            playMusic() {}
            pauseMusic() {}
            resumeMusic() {}
            playSfx() {}
        }
        
        // --------------------------------------------------------------------
        // ENGINE
        // --------------------------------------------------------------------
        
        class Engine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.mode = null;
                this.game = null;
                this.running = false;
                this.paused = false;
                this.input = new Input();
                this.audio = new Audio();
                this.sprites = null;
                this.renderer = null;
                this.lastTime = 0;
                this.accumulator = 0;
                this.frameInterval = 16.67;
                this.fps = 0;
            }
            
            async setMode(modeId) {
                const mode = MODES[modeId];
                if (!mode) return false;
                
                this.mode = mode;
                this.frameInterval = 1000 / mode.targetFPS;
                
                this.canvas.width = mode.canvas.width;
                this.canvas.height = mode.canvas.height;
                
                const scale = mode.displayScale;
                let width = mode.canvas.width * scale;
                let height = mode.canvas.height * scale;
                
                if (mode.pixelAspect) {
                    width *= mode.pixelAspect;
                }
                
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                
                this.renderer = new Renderer(this.canvas, mode);
                this.sprites = new SpriteManager(mode);
                
                return true;
            }
            
            async loadGame(game) {
                this.game = game;
                if (game.init) await game.init(this);
                if (game.sprites) await this.sprites.loadAll(game.sprites);
                return true;
            }
            
            start() {
                if (this.running) return;
                this.running = true;
                this.lastTime = performance.now();
                if (this.game?.start) this.game.start(this);
                this.loop(this.lastTime);
            }
            
            stop() {
                this.running = false;
            }
            
            setPaused(p) {
                this.paused = p;
            }
            
            togglePause() {
                this.paused = !this.paused;
            }
            
            canSpawn(type, count) {
                if (!this.mode) return true;
                switch (type) {
                    case 'ball': return count < this.mode.maxBallsOnScreen;
                    case 'harpoon': return count < this.mode.maxHarpoons;
                    default: return true;
                }
            }
            
            loop = (now) => {
                if (!this.running) return;
                
                const dt = now - this.lastTime;
                this.lastTime = now;
                
                this.accumulator += Math.min(dt, 100);
                
                while (this.accumulator >= this.frameInterval) {
                    this.input.update();
                    if (!this.paused && this.game?.update) {
                        this.game.update(this, this.frameInterval);
                    }
                    this.accumulator -= this.frameInterval;
                }
                
                if (this.game?.render) this.game.render(this);
                
                requestAnimationFrame(this.loop);
            }
        }
        
        // --------------------------------------------------------------------
        // CPCTELERA EXPORTER
        // Exports game data to CPCtelera-compatible C header files
        // For building actual CPC/GX4000 games
        // --------------------------------------------------------------------
        
        class CPCTeleraExporter {
            constructor() {
                // CPC hardware palette - firmware to hardware colour mapping
                this.CPC_PALETTE = {
                    // Firmware index -> { hw: hardware value, name: string, rgb: hex }
                    0:  { hw: 0x14, name: 'BLACK',          rgb: '#000000' },
                    1:  { hw: 0x04, name: 'BLUE',           rgb: '#000080' },
                    2:  { hw: 0x15, name: 'BRIGHT_BLUE',    rgb: '#0000FF' },
                    3:  { hw: 0x1C, name: 'RED',            rgb: '#800000' },
                    4:  { hw: 0x18, name: 'MAGENTA',        rgb: '#800080' },
                    5:  { hw: 0x1D, name: 'MAUVE',          rgb: '#8000FF' },
                    6:  { hw: 0x0C, name: 'BRIGHT_RED',     rgb: '#FF0000' },
                    7:  { hw: 0x05, name: 'PURPLE',         rgb: '#FF0080' },
                    8:  { hw: 0x0D, name: 'BRIGHT_MAGENTA', rgb: '#FF00FF' },
                    9:  { hw: 0x16, name: 'GREEN',          rgb: '#008000' },
                    10: { hw: 0x06, name: 'CYAN',           rgb: '#008080' },
                    11: { hw: 0x17, name: 'SKY_BLUE',       rgb: '#0080FF' },
                    12: { hw: 0x1E, name: 'YELLOW',         rgb: '#808000' },
                    13: { hw: 0x00, name: 'WHITE',          rgb: '#808080' },
                    14: { hw: 0x1F, name: 'PASTEL_BLUE',    rgb: '#8080FF' },
                    15: { hw: 0x0E, name: 'ORANGE',         rgb: '#FF8000' },
                    16: { hw: 0x07, name: 'PINK',           rgb: '#FF8080' },
                    17: { hw: 0x0F, name: 'PASTEL_MAGENTA', rgb: '#FF80FF' },
                    18: { hw: 0x12, name: 'BRIGHT_GREEN',   rgb: '#00FF00' },
                    19: { hw: 0x02, name: 'SEA_GREEN',      rgb: '#00FF80' },
                    20: { hw: 0x13, name: 'BRIGHT_CYAN',    rgb: '#00FFFF' },
                    21: { hw: 0x1A, name: 'LIME',           rgb: '#80FF00' },
                    22: { hw: 0x19, name: 'PASTEL_GREEN',   rgb: '#80FF80' },
                    23: { hw: 0x1B, name: 'PASTEL_CYAN',    rgb: '#80FFFF' },
                    24: { hw: 0x0A, name: 'BRIGHT_YELLOW',  rgb: '#FFFF00' },
                    25: { hw: 0x03, name: 'PASTEL_YELLOW',  rgb: '#FFFF80' },
                    26: { hw: 0x0B, name: 'BRIGHT_WHITE',   rgb: '#FFFFFF' }
                };
            }
            
            // Find closest CPC palette colour for an RGB value
            findClosestCPCColour(hexColour) {
                const r = parseInt(hexColour.slice(1, 3), 16);
                const g = parseInt(hexColour.slice(3, 5), 16);
                const b = parseInt(hexColour.slice(5, 7), 16);
                
                let bestMatch = 0;
                let bestDist = Infinity;
                
                for (let fw = 0; fw <= 26; fw++) {
                    const pal = this.CPC_PALETTE[fw];
                    const pr = parseInt(pal.rgb.slice(1, 3), 16);
                    const pg = parseInt(pal.rgb.slice(3, 5), 16);
                    const pb = parseInt(pal.rgb.slice(5, 7), 16);
                    
                    const dist = Math.sqrt((r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestMatch = fw;
                    }
                }
                
                return bestMatch;
            }
            
            // Generate C header for palette
            exportPalette(palette, name = 'g_palette') {
                let output = `//--------------------------------------------------------------------\n`;
                output += `// ${name}.h - CPC Palette Definition\n`;
                output += `// Generated by Retro Engine CPCtelera Exporter\n`;
                output += `// Use with: cpct_fw2hw() then cpct_setPalette()\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `#ifndef _${name.toUpperCase()}_H_\n`;
                output += `#define _${name.toUpperCase()}_H_\n\n`;
                output += `#include <types.h>\n\n`;
                
                // Firmware colours array
                output += `// Firmware colour values (0-26)\n`;
                output += `// Convert to hardware with cpct_fw2hw() before use\n`;
                output += `const u8 ${name}[${palette.length}] = {\n    `;
                
                const fwColours = palette.map(hex => this.findClosestCPCColour(hex));
                output += fwColours.map((fw, i) => {
                    const info = this.CPC_PALETTE[fw];
                    return `${fw.toString().padStart(2)}  /* ${info.name} */`;
                }).join(',\n    ');
                
                output += `\n};\n\n`;
                
                // Also output hardware values directly (pre-converted)
                output += `// Pre-converted hardware colour values\n`;
                output += `// Can be used directly with cpct_setPalette()\n`;
                output += `const u8 ${name}_hw[${palette.length}] = {\n    `;
                
                output += fwColours.map((fw, i) => {
                    const info = this.CPC_PALETTE[fw];
                    return `0x${info.hw.toString(16).padStart(2, '0').toUpperCase()}  /* ${info.name} */`;
                }).join(',\n    ');
                
                output += `\n};\n\n`;
                output += `#endif // _${name.toUpperCase()}_H_\n`;
                
                return output;
            }
            
            // Convert pixel data to CPC Mode 0 format (2 pixels per byte)
            pixelsToCPCMode0(pixels, width, height, palette) {
                const bytes = [];
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x += 2) {
                        const idx = (y * width + x) * 4;
                        
                        // Get palette indices for two pixels
                        const px0 = this.getPixelPaletteIndex(pixels, idx, palette);
                        const px1 = this.getPixelPaletteIndex(pixels, idx + 4, palette);
                        
                        // Convert to CPC Mode 0 byte format
                        // Pixel 0 bits: 7,3,5,1 | Pixel 1 bits: 6,2,4,0
                        const byte = this.encodeMode0Byte(px0, px1);
                        bytes.push(byte);
                    }
                }
                
                return bytes;
            }
            
            // Get palette index for a pixel (RGBA data)
            getPixelPaletteIndex(pixels, idx, palette) {
                const r = pixels[idx];
                const g = pixels[idx + 1];
                const b = pixels[idx + 2];
                const hex = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                
                let bestMatch = 0;
                let bestDist = Infinity;
                
                for (let i = 0; i < palette.length; i++) {
                    const pr = parseInt(palette[i].slice(1, 3), 16);
                    const pg = parseInt(palette[i].slice(3, 5), 16);
                    const pb = parseInt(palette[i].slice(5, 7), 16);
                    
                    const dist = Math.sqrt((r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestMatch = i;
                    }
                }
                
                return bestMatch;
            }
            
            // Encode two palette indices into a Mode 0 byte
            encodeMode0Byte(px0, px1) {
                // Mode 0: Each pixel is 4 bits (0-15)
                // Byte layout: [p0b3][p0b1][p1b3][p1b1][p0b2][p0b0][p1b2][p1b0]
                let byte = 0;
                
                // Pixel 0 bits
                if (px0 & 0x08) byte |= 0x80;  // bit 3 -> bit 7
                if (px0 & 0x04) byte |= 0x08;  // bit 2 -> bit 3
                if (px0 & 0x02) byte |= 0x20;  // bit 1 -> bit 5
                if (px0 & 0x01) byte |= 0x02;  // bit 0 -> bit 1
                
                // Pixel 1 bits
                if (px1 & 0x08) byte |= 0x40;  // bit 3 -> bit 6
                if (px1 & 0x04) byte |= 0x04;  // bit 2 -> bit 2
                if (px1 & 0x02) byte |= 0x10;  // bit 1 -> bit 4
                if (px1 & 0x01) byte |= 0x01;  // bit 0 -> bit 0
                
                return byte;
            }
            
            // Generate C header for sprite data
            exportSprite(spriteData, width, height, name = 'g_sprite') {
                const bytesPerRow = Math.ceil(width / 2);  // Mode 0: 2 pixels per byte
                const totalBytes = bytesPerRow * height;
                
                let output = `//--------------------------------------------------------------------\n`;
                output += `// ${name}.h - CPC Sprite Definition (Mode 0)\n`;
                output += `// Size: ${width}x${height} pixels = ${bytesPerRow}x${height} bytes\n`;
                output += `// Generated by Retro Engine CPCtelera Exporter\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `#ifndef _${name.toUpperCase()}_H_\n`;
                output += `#define _${name.toUpperCase()}_H_\n\n`;
                output += `#include <types.h>\n\n`;
                output += `#define ${name.toUpperCase()}_W  ${bytesPerRow}\n`;
                output += `#define ${name.toUpperCase()}_H  ${height}\n\n`;
                output += `// Sprite data in CPC Mode 0 screen pixel format\n`;
                output += `const u8 ${name}[${totalBytes}] = {\n`;
                
                for (let row = 0; row < height; row++) {
                    output += `    `;
                    for (let col = 0; col < bytesPerRow; col++) {
                        const idx = row * bytesPerRow + col;
                        output += `0x${spriteData[idx].toString(16).padStart(2, '0').toUpperCase()}`;
                        if (idx < totalBytes - 1) output += ', ';
                    }
                    output += `  // Row ${row}\n`;
                }
                
                output += `};\n\n`;
                output += `#endif // _${name.toUpperCase()}_H_\n`;
                
                return output;
            }
            
            // Export game constants header
            exportGameConstants(mode, gameState) {
                let output = `//--------------------------------------------------------------------\n`;
                output += `// game_constants.h - Game Constants for CPCtelera\n`;
                output += `// Target: ${mode.id === '8bit-gx4000' ? 'GX4000/CPC Plus' : 'Amstrad CPC'}\n`;
                output += `// Generated by Retro Engine CPCtelera Exporter\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `#ifndef _GAME_CONSTANTS_H_\n`;
                output += `#define _GAME_CONSTANTS_H_\n\n`;
                
                // Screen dimensions
                output += `// Screen dimensions (Mode 0)\n`;
                output += `#define SCREEN_W        ${mode.canvas.width}\n`;
                output += `#define SCREEN_H        ${mode.canvas.height}\n`;
                output += `#define SCREEN_BYTES_W  ${Math.ceil(mode.canvas.width / 2)}\n\n`;
                
                // Playfield
                output += `// Playfield dimensions\n`;
                output += `#define BORDER_SIZE     8\n`;
                output += `#define PLAYFIELD_X     BORDER_SIZE\n`;
                output += `#define PLAYFIELD_Y     16\n`;
                output += `#define PLAYFIELD_W     (SCREEN_W - BORDER_SIZE * 2)\n`;
                output += `#define PLAYFIELD_H     (SCREEN_H - BORDER_SIZE - 16)\n`;
                output += `#define FLOOR_Y         (PLAYFIELD_Y + PLAYFIELD_H)\n\n`;
                
                // Player
                output += `// Player constants\n`;
                output += `#define PLAYER_W        8   // 16 pixels = 8 bytes in Mode 0\n`;
                output += `#define PLAYER_H        24\n`;
                output += `#define PLAYER_SPEED    ${Math.round(2.5 * (mode.canvas.width / 320) * 256)}  // Fixed point 8.8\n\n`;
                
                // Ball sizes
                output += `// Ball sizes (radius in pixels)\n`;
                output += `#define BALL_LARGE_R    16\n`;
                output += `#define BALL_MEDIUM_R   10\n`;
                output += `#define BALL_SMALL_R    6\n\n`;
                
                // Physics
                output += `// Physics (fixed point 8.8 format)\n`;
                output += `#define GRAVITY         ${Math.round(0.15 * 256)}   // 0.15 * 256\n`;
                output += `#define BOUNCE_VEL      ${Math.round(-5.5 * 256)}  // -5.5 * 256 (upward)\n`;
                output += `#define HARPOON_SPEED   ${Math.round(7.0 * 256)}   // 7.0 * 256\n\n`;
                
                // Limits
                output += `// Game limits\n`;
                output += `#define MAX_BALLS       ${mode.maxBallsOnScreen}\n`;
                output += `#define MAX_HARPOONS    ${mode.maxHarpoons}\n`;
                output += `#define MAX_POWERUPS    ${mode.maxPowerUps}\n\n`;
                
                output += `#endif // _GAME_CONSTANTS_H_\n`;
                
                return output;
            }
            
            // Export main.c template
            exportMainTemplate(mode) {
                const isGX4000 = mode.id === '8bit-gx4000';
                
                let output = `//--------------------------------------------------------------------\n`;
                output += `// main.c - Pang for ${isGX4000 ? 'GX4000/CPC Plus' : 'Amstrad CPC'}\n`;
                output += `// Generated by Retro Engine CPCtelera Exporter\n`;
                output += `// Build with CPCtelera: make\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `#include <cpctelera.h>\n`;
                output += `#include "game_constants.h"\n`;
                output += `#include "palette.h"\n`;
                output += `// #include "sprites/player.h"\n`;
                output += `// #include "sprites/balls.h"\n\n`;
                
                // Type definitions
                output += `//--------------------------------------------------------------------\n`;
                output += `// Type definitions\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `typedef struct {\n`;
                output += `    i16 x, y;       // Position (fixed point 8.8)\n`;
                output += `    i8  vx, vy;     // Velocity\n`;
                output += `    u8  state;      // Current state\n`;
                output += `    u8  frame;      // Animation frame\n`;
                output += `} Entity;\n\n`;
                
                output += `typedef struct {\n`;
                output += `    i16 x, y;       // Position (fixed point 8.8)\n`;
                output += `    i16 vy;         // Y velocity\n`;
                output += `    u8  size;       // 0=large, 1=medium, 2=small\n`;
                output += `    i8  dir;        // -1=left, 1=right\n`;
                output += `    u8  active;     // Is ball active?\n`;
                output += `} Ball;\n\n`;
                
                // Global state
                output += `//--------------------------------------------------------------------\n`;
                output += `// Global state\n`;
                output += `//--------------------------------------------------------------------\n\n`;
                output += `Entity g_player;\n`;
                output += `Ball   g_balls[MAX_BALLS];\n`;
                output += `u8     g_numBalls;\n`;
                output += `u8     g_harpoonActive;\n`;
                output += `i16    g_harpoonY;\n`;
                output += `u16    g_score;\n`;
                output += `u8     g_lives;\n\n`;
                
                // Init function
                output += `//--------------------------------------------------------------------\n`;
                output += `// Initialize CPC hardware\n`;
                output += `//--------------------------------------------------------------------\n`;
                output += `void initCPC() {\n`;
                output += `    cpct_disableFirmware();\n`;
                output += `    cpct_fw2hw(g_palette, 16);\n`;
                output += `    cpct_setPalette(g_palette, 16);\n`;
                output += `    cpct_setBorder(g_palette[0]);\n`;
                output += `    cpct_setVideoMode(0);  // Mode 0: 160x200, 16 colours\n`;
                output += `}\n\n`;
                
                // Game init
                output += `//--------------------------------------------------------------------\n`;
                output += `// Initialize game state\n`;
                output += `//--------------------------------------------------------------------\n`;
                output += `void initGame() {\n`;
                output += `    // Player at centre bottom\n`;
                output += `    g_player.x = (SCREEN_W / 2) << 8;\n`;
                output += `    g_player.y = (FLOOR_Y - PLAYER_H) << 8;\n`;
                output += `    g_player.state = 0;\n`;
                output += `    g_player.frame = 0;\n\n`;
                output += `    // Start with one large ball\n`;
                output += `    g_numBalls = 1;\n`;
                output += `    g_balls[0].x = (SCREEN_W / 4) << 8;\n`;
                output += `    g_balls[0].y = (PLAYFIELD_Y + 20) << 8;\n`;
                output += `    g_balls[0].vy = 0;\n`;
                output += `    g_balls[0].size = 0;  // Large\n`;
                output += `    g_balls[0].dir = 1;\n`;
                output += `    g_balls[0].active = 1;\n\n`;
                output += `    g_harpoonActive = 0;\n`;
                output += `    g_score = 0;\n`;
                output += `    g_lives = 3;\n`;
                output += `}\n\n`;
                
                // Update function stub
                output += `//--------------------------------------------------------------------\n`;
                output += `// Update game logic (called each frame)\n`;
                output += `//--------------------------------------------------------------------\n`;
                output += `void updateGame() {\n`;
                output += `    // Scan keyboard\n`;
                output += `    cpct_scanKeyboard();\n\n`;
                output += `    // Player movement\n`;
                output += `    if (cpct_isKeyPressed(Key_CursorLeft) || cpct_isKeyPressed(Joy0_Left)) {\n`;
                output += `        g_player.x -= PLAYER_SPEED;\n`;
                output += `        g_player.state = 1;  // Facing left\n`;
                output += `    }\n`;
                output += `    else if (cpct_isKeyPressed(Key_CursorRight) || cpct_isKeyPressed(Joy0_Right)) {\n`;
                output += `        g_player.x += PLAYER_SPEED;\n`;
                output += `        g_player.state = 2;  // Facing right\n`;
                output += `    }\n`;
                output += `    else {\n`;
                output += `        g_player.state = 0;  // Idle\n`;
                output += `    }\n\n`;
                output += `    // Clamp player position\n`;
                output += `    if (g_player.x < (PLAYFIELD_X << 8)) g_player.x = PLAYFIELD_X << 8;\n`;
                output += `    if (g_player.x > ((SCREEN_W - PLAYFIELD_X - PLAYER_W * 2) << 8))\n`;
                output += `        g_player.x = (SCREEN_W - PLAYFIELD_X - PLAYER_W * 2) << 8;\n\n`;
                output += `    // Fire harpoon\n`;
                output += `    if (!g_harpoonActive && \n`;
                output += `        (cpct_isKeyPressed(Key_Space) || cpct_isKeyPressed(Joy0_Fire1))) {\n`;
                output += `        g_harpoonActive = 1;\n`;
                output += `        g_harpoonY = (FLOOR_Y - 4) << 8;\n`;
                output += `    }\n\n`;
                output += `    // Update harpoon\n`;
                output += `    if (g_harpoonActive) {\n`;
                output += `        g_harpoonY -= HARPOON_SPEED;\n`;
                output += `        if (g_harpoonY < (PLAYFIELD_Y << 8)) {\n`;
                output += `            g_harpoonActive = 0;\n`;
                output += `        }\n`;
                output += `    }\n\n`;
                output += `    // TODO: Update balls, check collisions\n`;
                output += `}\n\n`;
                
                // Render stub
                output += `//--------------------------------------------------------------------\n`;
                output += `// Render game (called each frame)\n`;
                output += `//--------------------------------------------------------------------\n`;
                output += `void renderGame() {\n`;
                output += `    u8* pvmem;\n\n`;
                output += `    // Clear screen (or redraw background)\n`;
                output += `    cpct_clearScreen(0);\n\n`;
                output += `    // Draw player\n`;
                output += `    pvmem = cpct_getScreenPtr(CPCT_VMEM_START, g_player.x >> 8, g_player.y >> 8);\n`;
                output += `    // cpct_drawSpriteMasked(g_player_sprite, pvmem, PLAYER_W, PLAYER_H);\n\n`;
                output += `    // Draw balls\n`;
                output += `    // TODO: Draw each active ball\n\n`;
                output += `    // Draw harpoon\n`;
                output += `    if (g_harpoonActive) {\n`;
                output += `        // TODO: Draw harpoon line\n`;
                output += `    }\n`;
                output += `}\n\n`;
                
                // Main function
                output += `//--------------------------------------------------------------------\n`;
                output += `// Main entry point\n`;
                output += `//--------------------------------------------------------------------\n`;
                output += `void main(void) {\n`;
                output += `    initCPC();\n`;
                output += `    initGame();\n\n`;
                output += `    while(1) {\n`;
                output += `        cpct_waitVSYNC();\n`;
                output += `        updateGame();\n`;
                output += `        renderGame();\n`;
                output += `    }\n`;
                output += `}\n`;
                
                return output;
            }
            
            // Export Makefile
            exportMakefile(projectName = 'pang') {
                let output = `#--------------------------------------------------------------------\n`;
                output += `# Makefile for ${projectName} - CPCtelera Project\n`;
                output += `# Generated by Retro Engine CPCtelera Exporter\n`;
                output += `#--------------------------------------------------------------------\n\n`;
                output += `# Project configuration\n`;
                output += `PROJECTNAME := ${projectName}\n\n`;
                output += `# CPCtelera path (adjust if needed)\n`;
                output += `CPCTROOT := $(HOME)/cpctelera\n\n`;
                output += `# Include CPCtelera build system\n`;
                output += `include $(CPCTROOT)/cfg/build_config.mk\n\n`;
                output += `# Source files\n`;
                output += `SOURCES := src/main.c\n\n`;
                output += `# Asset files (add your converted sprites here)\n`;
                output += `# ASSETS := src/sprites/player.c src/sprites/balls.c\n\n`;
                output += `# Build targets\n`;
                output += `include $(CPCTROOT)/cfg/global_main_makefile.mk\n`;
                
                return output;
            }
            
            // Download file helper
            downloadFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Download ZIP helper (using JSZip if available, or individual files)
            async downloadProject(mode, gameState, projectName = 'pang_cpc') {
                // Create all files
                const files = {};
                
                // Generate default palette based on mode
                const defaultPalette = mode.id === '8bit-gx4000' || mode.id === '8bit-cpc' ? [
                    '#000000', '#0000FF', '#FF0000', '#FF00FF',
                    '#00FF00', '#00FFFF', '#FFFF00', '#FFFFFF',
                    '#000080', '#800000', '#800080', '#008000',
                    '#008080', '#808000', '#808080', '#FF8000'
                ] : ['#000000', '#FFFFFF'];
                
                files['src/main.c'] = this.exportMainTemplate(mode);
                files['src/game_constants.h'] = this.exportGameConstants(mode, gameState);
                files['src/palette.h'] = this.exportPalette(defaultPalette, 'g_palette');
                files['Makefile'] = this.exportMakefile(projectName);
                files['README.txt'] = this.exportReadme(mode, projectName);
                
                // Check if JSZip is available
                if (typeof JSZip !== 'undefined') {
                    const zip = new JSZip();
                    for (const [path, content] of Object.entries(files)) {
                        zip.file(path, content);
                    }
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${projectName}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    // Download files individually
                    for (const [path, content] of Object.entries(files)) {
                        const filename = path.replace(/\//g, '_');
                        this.downloadFile(content, filename);
                        await new Promise(r => setTimeout(r, 200)); // Small delay between downloads
                    }
                }
            }
            
            // Generate README
            exportReadme(mode, projectName) {
                const isGX4000 = mode.id === '8bit-gx4000';
                
                let output = `${projectName.toUpperCase()} - Amstrad CPC Game\n`;
                output += `${'='.repeat(projectName.length + 20)}\n\n`;
                output += `Target Platform: ${isGX4000 ? 'GX4000 / CPC Plus (.CPR cartridge)' : 'Amstrad CPC (.DSK disk)'}\n`;
                output += `Video Mode: Mode 0 (160x200, 16 colours)\n`;
                output += `Generated by: Retro Engine CPCtelera Exporter\n\n`;
                output += `BUILDING\n`;
                output += `--------\n`;
                output += `1. Install CPCtelera: https://github.com/lronaldo/cpctelera\n`;
                output += `2. Set CPCTROOT in Makefile to your CPCtelera path\n`;
                output += `3. Run: make\n\n`;
                output += `OUTPUT\n`;
                output += `------\n`;
                output += `- ${projectName}.dsk - Disk image for emulators\n`;
                output += `- ${projectName}.cdt - Tape image\n`;
                if (isGX4000) {
                    output += `- ${projectName}.cpr - Cartridge ROM for GX4000\n`;
                }
                output += `\nTESTING\n`;
                output += `-------\n`;
                output += `Use WinAPE, RetroVirtualMachine, or Arnold emulator.\n`;
                output += `For GX4000: RetroVirtualMachine has best Plus/GX4000 support.\n\n`;
                output += `FILES\n`;
                output += `-----\n`;
                output += `src/main.c          - Main game code\n`;
                output += `src/game_constants.h - Game constants and physics\n`;
                output += `src/palette.h       - Colour palette definition\n`;
                output += `Makefile            - Build configuration\n\n`;
                output += `TODO\n`;
                output += `----\n`;
                output += `1. Add sprite graphics (use img2cpc tool)\n`;
                output += `2. Implement ball physics and collision\n`;
                output += `3. Add background graphics\n`;
                output += `4. Add sound effects (Arkos Tracker)\n`;
                
                return output;
            }
        }
        
        // Global exporter instance
        const cpcExporter = new CPCTeleraExporter();
        
        // --------------------------------------------------------------------
        // PANG GAME - SPRITE DEFINITIONS
        // --------------------------------------------------------------------
        
        // Ball sizes - based on authentic Spectrum Pang screenshots
        // Original game: Large ball is roughly 16-18 pixels radius (32-36 diameter)
        // But screen is 256x192, so relative to player (~24px tall), ball is about 16px radius
        // Ball sizes - radius in pixels, scaled to each mode's resolution
        // CPC & GX4000 both use Mode 0 (160x200) but GX4000 can handle more/smoother
        const BALL_SIZES = {
            '1bit':       { large: 16, medium: 10, small: 6 },
            '8bit-basic': { large: 16, medium: 10, small: 6 },  // Match original Spectrum
            '8bit-cpc':   { large: 8, medium: 5, small: 3 },    // CPC Mode 0 - simpler balls
            '8bit-plus':  { large: 16, medium: 10, small: 6 },  // Generic Plus (320x200)
            '8bit-gx4000': { large: 8, medium: 5, small: 3 },   // GX4000 Mode 0 - same size
            '16bit':      { large: 18, medium: 12, small: 7 }
        };
        
        // Player sizes - scaled to each mode's resolution
        // GX4000 Mode 0 (160x200) uses smaller sprites than Mode 1 (320x200)
        const PLAYER_SIZES = {
            '1bit':       { width: 16, height: 24 },
            '8bit-basic': { width: 16, height: 24 },  // Match original Spectrum
            '8bit-cpc':   { width: 16, height: 24 },  // CPC Mode 0
            '8bit-plus':  { width: 24, height: 32 },  // Generic Plus (320x200)
            '8bit-gx4000': { width: 12, height: 20 }, // GX4000 Mode 0 (160x200) - compact sprite
            '16bit':      { width: 28, height: 36 }
        };
        
        // ===================================================================
        // PHYSICS REFERENCE - 8-BIT PLUS (GX4000) @ 50 FPS
        // All modes normalize to this reference for consistent gameplay
        // ===================================================================
        const REFERENCE_FPS = 50;
        
        // Base physics values at 50 FPS (8-bit Plus reference)
        // These are multiplied by delta time factor to be frame-rate independent
        const BASE_PHYSICS = {
            gravity: 0.15,          // Pixels per frame^2 at 50fps
            bounceVelocity: -5.5,   // Pixels per frame at 50fps (upward)
            spawnVelocityY: -3.0,   // Initial Y velocity when ball spawns/splits
            ballSpeeds: {
                large: 1.0,         // Pixels per frame at 50fps
                medium: 1.4,
                small: 1.8
            },
            playerSpeed: 2.5,       // Pixels per frame at 50fps
            harpoonSpeed: 7.0       // Pixels per frame at 50fps
        };
        
        // Scale factors for different resolutions (relative to 8-bit Plus 320x200)
        // Used for physics/gameplay normalization across modes
        const SCALE_FACTORS = {
            '1bit':       { x: 256 / 320, y: 192 / 200 },   // ~0.8x
            '8bit-basic': { x: 256 / 320, y: 192 / 200 },   // ~0.8x
            '8bit-cpc':   { x: 160 / 320, y: 200 / 200 },   // 0.5x width (Mode 0)
            '8bit-plus':  { x: 1.0, y: 1.0 },               // Reference (Generic Plus, Mode 1)
            '8bit-gx4000': { x: 160 / 320, y: 200 / 200 },  // 0.5x width (Mode 0, like CPC)
            '16bit':      { x: 320 / 320, y: 224 / 200 }    // ~1.12x height
        };
        
        // LEGACY: Kept for backward compatibility but not used in physics
        const BALL_SPEEDS = {
            '1bit':       { large: 0.8, medium: 1.1, small: 1.4 },
            '8bit-basic': { large: 0.8, medium: 1.1, small: 1.4 },
            '8bit-cpc':   { large: 0.5, medium: 0.7, small: 0.9 },
            '8bit-plus':  { large: 1.0, medium: 1.4, small: 1.8 },
            '16bit':      { large: 1.0, medium: 1.4, small: 1.8 }
        };
        
        const PANG_SPRITES = {
            player: {
                software: {
                    '8bit-cpc': {
                        idle: ['assets/pang/8bit-cpc/player_walk_1.png'],
                        walk: [
                            'assets/pang/8bit-cpc/player_walk_1.png',
                            'assets/pang/8bit-cpc/player_walk_2.png',
                            'assets/pang/8bit-cpc/player_walk_3.png',
                            'assets/pang/8bit-cpc/player_walk_4.png',
                            'assets/pang/8bit-cpc/player_walk_5.png'
                        ]
                    }
                },
                tilesheet: {}
            }
        };
        
        // ===================================================================
        // BACKGROUND DEFINITIONS
        // ===================================================================
        // Backgrounds can be:
        // 1. PNG image path (string) - for colour modes
        // 2. Software definition (object) - for 1-bit and Spectrum modes
        //
        // Software backgrounds use simple shapes that are authentic to the
        // original hardware limitations.
        // ===================================================================
        
        // Software background definitions for 1-bit and Spectrum modes
        // All coordinates are 0-1 normalized (relative to playfield)
        // Based on authentic ZX Spectrum Pang screenshots
        const SOFTWARE_BACKGROUNDS = {
            // Mt. Fuji - Stage 1-1 (authentic Spectrum Pang recreation)
            // Reference: ZX Spectrum Pang by Ocean (1990)
            mtfuji: {
                elements: [
                    // ===== DISTANT MOUNTAINS (background layer) =====
                    // Far right small mountain
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.85, y: 0.55 },
                            { x: 0.75, y: 0.75 },
                            { x: 0.95, y: 0.75 }
                        ],
                        fill: true,
                        dither: 0.35
                    },
                    
                    // ===== MAIN MT. FUJI (centre-right) =====
                    // Mountain body - medium dither
                    { 
                        type: 'polygon',
                        points: [
                            { x: 0.65, y: 0.08 },   // Peak
                            { x: 0.30, y: 0.75 },   // Left base
                            { x: 1.0, y: 0.75 }     // Right base
                        ],
                        fill: true,
                        dither: 0.45
                    },
                    // Snow cap - solid white (no dither)
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.65, y: 0.08 },   // Peak
                            { x: 0.55, y: 0.22 },   // Left snow line
                            { x: 0.58, y: 0.20 },   // Snow detail
                            { x: 0.62, y: 0.24 },   // Snow detail
                            { x: 0.68, y: 0.18 },   // Snow detail
                            { x: 0.72, y: 0.25 },   // Snow detail
                            { x: 0.75, y: 0.22 }    // Right snow line
                        ],
                        fill: true,
                        dither: 1.0  // Solid white
                    },
                    // Snow patches on mountain (lighter dither areas)
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.52, y: 0.35 },
                            { x: 0.48, y: 0.45 },
                            { x: 0.55, y: 0.40 }
                        ],
                        fill: true,
                        dither: 0.75
                    },
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.72, y: 0.30 },
                            { x: 0.68, y: 0.42 },
                            { x: 0.78, y: 0.38 }
                        ],
                        fill: true,
                        dither: 0.70
                    },
                    
                    // ===== FOREGROUND HILLS/TERRAIN =====
                    // Left foreground hill
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.0, y: 0.55 },
                            { x: 0.15, y: 0.45 },
                            { x: 0.35, y: 0.55 },
                            { x: 0.35, y: 0.85 },
                            { x: 0.0, y: 0.85 }
                        ],
                        fill: true,
                        dither: 0.30
                    },
                    
                    // ===== HORIZONTAL CLOUD/MIST LAYERS =====
                    // These create the layered atmospheric effect
                    {
                        type: 'rect',
                        x: 0.0, y: 0.58,
                        width: 0.45, height: 0.015,
                        fill: true,
                        dither: 0.55
                    },
                    {
                        type: 'rect',
                        x: 0.0, y: 0.62,
                        width: 0.50, height: 0.012,
                        fill: true,
                        dither: 0.50
                    },
                    {
                        type: 'rect',
                        x: 0.0, y: 0.66,
                        width: 0.55, height: 0.015,
                        fill: true,
                        dither: 0.45
                    },
                    {
                        type: 'rect',
                        x: 0.0, y: 0.70,
                        width: 0.60, height: 0.012,
                        fill: true,
                        dither: 0.40
                    },
                    
                    // ===== GROUND/WATER AREA =====
                    // Bottom ground with subtle horizontal lines
                    {
                        type: 'rect',
                        x: 0, y: 0.78,
                        width: 1, height: 0.04,
                        fill: true,
                        dither: 0.35
                    },
                    {
                        type: 'rect',
                        x: 0, y: 0.84,
                        width: 1, height: 0.03,
                        fill: true,
                        dither: 0.30
                    },
                    {
                        type: 'rect',
                        x: 0, y: 0.89,
                        width: 1, height: 0.11,
                        fill: true,
                        dither: 0.25
                    }
                ]
            },
            
            // Legacy mountain (simpler version)
            mountain: {
                elements: [
                    // Main mountain (large triangle/polygon)
                    { 
                        type: 'polygon',
                        points: [
                            { x: 0.5, y: 0.1 },   // Peak
                            { x: 0.15, y: 0.7 },  // Left base
                            { x: 0.85, y: 0.7 }   // Right base
                        ],
                        fill: true,
                        dither: 0.5
                    },
                    // Snow cap (lighter dither at peak)
                    {
                        type: 'polygon',
                        points: [
                            { x: 0.5, y: 0.1 },
                            { x: 0.4, y: 0.25 },
                            { x: 0.6, y: 0.25 }
                        ],
                        fill: true,
                        dither: 0.95
                    },
                    // Ground/horizon line
                    {
                        type: 'rect',
                        x: 0, y: 0.7,
                        width: 1, height: 0.3,
                        fill: true,
                        dither: 0.25
                    }
                ]
            },
            
            // Desert scene with dunes and cacti silhouettes
            desert: {
                elements: [
                    // Far dune (background)
                    {
                        type: 'polygon',
                        points: [
                            { x: 0, y: 0.5 },
                            { x: 0.3, y: 0.35 },
                            { x: 0.6, y: 0.45 },
                            { x: 1.0, y: 0.4 },
                            { x: 1.0, y: 0.7 },
                            { x: 0, y: 0.7 }
                        ],
                        fill: true,
                        dither: 0.5
                    },
                    // Near dune (foreground) - darker
                    {
                        type: 'polygon',
                        points: [
                            { x: 0, y: 0.65 },
                            { x: 0.2, y: 0.55 },
                            { x: 0.5, y: 0.6 },
                            { x: 0.8, y: 0.5 },
                            { x: 1.0, y: 0.58 },
                            { x: 1.0, y: 1.0 },
                            { x: 0, y: 1.0 }
                        ],
                        fill: true,
                        dither: 0.35
                    },
                    // Cactus 1 (left)
                    {
                        type: 'rect',
                        x: 0.12, y: 0.45,
                        width: 0.02, height: 0.2,
                        fill: true,
                        dither: 0.7
                    },
                    {
                        type: 'rect',
                        x: 0.08, y: 0.5,
                        width: 0.04, height: 0.015,
                        fill: true,
                        dither: 0.7
                    },
                    {
                        type: 'rect',
                        x: 0.14, y: 0.48,
                        width: 0.04, height: 0.015,
                        fill: true,
                        dither: 0.7
                    },
                    // Cactus 2 (right)
                    {
                        type: 'rect',
                        x: 0.82, y: 0.38,
                        width: 0.025, height: 0.25,
                        fill: true,
                        dither: 0.65
                    },
                    {
                        type: 'rect',
                        x: 0.77, y: 0.45,
                        width: 0.05, height: 0.018,
                        fill: true,
                        dither: 0.65
                    },
                    {
                        type: 'rect',
                        x: 0.845, y: 0.42,
                        width: 0.05, height: 0.018,
                        fill: true,
                        dither: 0.65
                    },
                    // Sun/moon circle (top right)
                    {
                        type: 'circle',
                        x: 0.8, y: 0.15,
                        radius: 0.08,
                        fill: true,
                        dither: 0.95  // Very bright
                    }
                ]
            },
            
            // Simple city skyline
            city: {
                elements: [
                    // Building 1
                    { type: 'rect', x: 0.05, y: 0.4, width: 0.1, height: 0.6, fill: true, dither: 0.5 },
                    // Building 2 (tall)
                    { type: 'rect', x: 0.18, y: 0.2, width: 0.08, height: 0.8, fill: true, dither: 0.55 },
                    // Building 3
                    { type: 'rect', x: 0.28, y: 0.35, width: 0.12, height: 0.65, fill: true, dither: 0.45 },
                    // Building 4
                    { type: 'rect', x: 0.42, y: 0.5, width: 0.1, height: 0.5, fill: true, dither: 0.5 },
                    // Building 5 (tallest)
                    { type: 'rect', x: 0.54, y: 0.15, width: 0.1, height: 0.85, fill: true, dither: 0.6 },
                    // Building 6
                    { type: 'rect', x: 0.66, y: 0.3, width: 0.12, height: 0.7, fill: true, dither: 0.5 },
                    // Building 7
                    { type: 'rect', x: 0.8, y: 0.45, width: 0.15, height: 0.55, fill: true, dither: 0.55 }
                ]
            }
        };
        
        // Background configuration per mode per level
        // Spectrum Pang Stage 1-1 is MT FUJI (per screenshots)
        const PANG_BACKGROUNDS = {
            level1: {
                // 1-bit and Spectrum use software-defined backgrounds
                // Stage 1-1 is MT FUJI in authentic Spectrum Pang
                '1bit': { type: 'software', def: 'mtfuji' },
                '8bit-basic': { type: 'software', def: 'mtfuji' },
                // Colour modes use PNG images
                '8bit-cpc': 'games/pang/assets/backgrounds/level1/8bit-cpc.png',
                '8bit-plus': 'games/pang/assets/backgrounds/level1/8bit-plus.png',
                '16bit': 'games/pang/assets/backgrounds/level1/16bit.png'
            },
            level2: {
                '1bit': { type: 'software', def: 'city' },
                '8bit-basic': { type: 'software', def: 'city' },
                '8bit-cpc': 'games/pang/assets/backgrounds/level1/8bit-cpc.png',
                '8bit-plus': 'games/pang/assets/backgrounds/level1/8bit-plus.png',
                '16bit': 'games/pang/assets/backgrounds/level1/16bit.png'
            },
            level3: {
                '1bit': { type: 'software', def: 'desert' },
                '8bit-basic': { type: 'software', def: 'desert' },
                '8bit-cpc': 'games/pang/assets/backgrounds/level1/8bit-cpc.png',
                '8bit-plus': 'games/pang/assets/backgrounds/level1/8bit-plus.png',
                '16bit': 'games/pang/assets/backgrounds/level1/16bit.png'
            }
        };
        
        // --------------------------------------------------------------------
        // PANG GAME
        // --------------------------------------------------------------------
        
        const PangGame = {
            name: 'Pang',
            sprites: PANG_SPRITES,
            state: 'title',
            player: null,
            balls: [],
            harpoons: [],
            lives: 3,
            score: 0,
            highScore: 100000,
            levelTimer: 60,
            currentLevel: 1,
            lastShotTime: 0,
            harpoonCooldown: 350,
            config: null,
            backgrounds: {},  // Cache for loaded background images
            currentBackground: null,
            
            // Level definitions - Stage 1-1 is MT FUJI (per authentic Spectrum Pang)
            // Mode-aware: CPC has fewer balls due to software sprite limit
            levels: {
                1: { name: 'MT FUJI', stage: '1-1', timer: 99, background: 'level1', balls: [{ x: 0.2, y: 0.3, size: 'large', dir: 1 }] },
                2: { name: 'MT FUJI', stage: '1-2', timer: 99, background: 'level1', balls: [{ x: 0.25, y: 0.3, size: 'large', dir: 1 }, { x: 0.75, y: 0.3, size: 'large', dir: -1 }] },
                3: { name: 'CITY', stage: '2-1', timer: 90, background: 'level2', balls: [{ x: 0.2, y: 0.4, size: 'large', dir: 1 }, { x: 0.5, y: 0.5, size: 'medium', dir: -1 }, { x: 0.8, y: 0.4, size: 'large', dir: -1 }] }
            },
            
            // Get mode-appropriate balls for a level (respects maxBallsOnScreen)
            getModeBalls(levelBalls, mode) {
                // For CPC, limit starting balls to ensure we don't exceed max when splitting
                // Each large ball can become up to 4 small balls (large -> 2 medium -> 4 small)
                const maxBalls = mode.maxBallsOnScreen || 14;
                const potentialBalls = levelBalls.reduce((total, b) => {
                    if (b.size === 'large') return total + 4;  // Can split to 4
                    if (b.size === 'medium') return total + 2; // Can split to 2
                    return total + 1;
                }, 0);
                
                // If potential balls exceed limit, reduce starting balls
                if (potentialBalls > maxBalls) {
                    // Return fewer balls for limited modes
                    const ratio = maxBalls / potentialBalls;
                    const keepCount = Math.max(1, Math.floor(levelBalls.length * ratio));
                    return levelBalls.slice(0, keepCount);
                }
                return levelBalls;
            },
            
            async init(engine) {
                this.config = this.getModeConfig(engine.mode);
                this.player = {
                    x: engine.mode.canvas.width / 2,
                    y: this.config.floorY,  // y is the feet position (bottom of player)
                    width: this.config.playerWidth,
                    height: this.config.playerHeight,
                    speed: this.config.playerSpeed,
                    facing: 0,       // 0 = forward (back to screen), -1 = left, 1 = right
                    isWalking: false,
                    isShooting: false,
                    shootTimer: 0,
                    walkTimer: 0,
                    bobOffset: 0
                };
                engine.input.onKeyDown = (code) => this.handleKeyPress(code, engine);
                
                // Preload backgrounds for current mode
                await this.loadBackgrounds(engine.mode.id);
            },
            
            // Load background images/definitions for the current mode
            async loadBackgrounds(modeId) {
                for (const [levelKey, bgConfig] of Object.entries(PANG_BACKGROUNDS)) {
                    const config = bgConfig[modeId];
                    if (!config) continue;
                    
                    // Check if it's a software definition or PNG path
                    if (typeof config === 'object' && config.type === 'software') {
                        // Software-defined background
                        const def = SOFTWARE_BACKGROUNDS[config.def];
                        if (def) {
                            this.backgrounds[levelKey] = { type: 'software', def: def };
                        } else {
                            console.warn(`Software background not found: ${config.def}`);
                            this.backgrounds[levelKey] = null;
                        }
                    } else if (typeof config === 'string') {
                        // PNG image path
                        try {
                            const img = new Image();
                            await new Promise((resolve, reject) => {
                                img.onload = resolve;
                                img.onerror = reject;
                                img.src = config;
                            });
                            this.backgrounds[levelKey] = { type: 'image', img: img };
                        } catch (e) {
                            console.warn(`Failed to load background: ${config}`);
                            this.backgrounds[levelKey] = null;
                        }
                    }
                }
            },
            
            getModeConfig(mode) {
                const W = mode.canvas.width;
                const H = mode.canvas.height;
                const hudHeight = Math.floor(H * 0.24);
                const borderSize = 8;
                const floorY = H - hudHeight - borderSize;
                
                // Calculate frame-rate compensation factor
                // All physics are defined at 50fps (reference), scale for target FPS
                const fpsRatio = REFERENCE_FPS / mode.targetFPS;
                
                // Get resolution scale factor for this mode
                const scale = SCALE_FACTORS[mode.id] || SCALE_FACTORS['8bit-plus'];
                
                // Calculate scaled physics values
                // Speed values are scaled by resolution (smaller screen = slower movement)
                // but adjusted for frame rate to maintain consistent real-time speed
                const scaledBallSpeeds = {
                    large: BASE_PHYSICS.ballSpeeds.large * scale.x * fpsRatio,
                    medium: BASE_PHYSICS.ballSpeeds.medium * scale.x * fpsRatio,
                    small: BASE_PHYSICS.ballSpeeds.small * scale.x * fpsRatio
                };
                
                return {
                    width: W, height: H, hudHeight, borderSize, floorY,
                    playfieldTop: borderSize,
                    playfieldLeft: borderSize,
                    playfieldRight: W - borderSize,
                    playfieldWidth: W - borderSize * 2,
                    playfieldHeight: floorY - borderSize,
                    playerWidth: (PLAYER_SIZES[mode.id] || PLAYER_SIZES['16bit']).width,
                    playerHeight: (PLAYER_SIZES[mode.id] || PLAYER_SIZES['16bit']).height,
                    // Player speed scaled by resolution and FPS
                    playerSpeed: BASE_PHYSICS.playerSpeed * scale.x * fpsRatio,
                    ballRadius: BALL_SIZES[mode.id] || BALL_SIZES['16bit'],
                    ballSpeed: scaledBallSpeeds,
                    // Gravity and bounce scaled by FPS ratio squared (acceleration) and linear (velocity)
                    gravity: BASE_PHYSICS.gravity * scale.y * (fpsRatio * fpsRatio),
                    bounceVY: BASE_PHYSICS.bounceVelocity * scale.y * fpsRatio,
                    spawnVY: BASE_PHYSICS.spawnVelocityY * scale.y * fpsRatio,
                    harpoonSpeed: BASE_PHYSICS.harpoonSpeed * scale.y * fpsRatio,
                    harpoonHeadH: Math.round(20 * scale.y),
                    harpoonBodyW: Math.round(8 * scale.x),
                    scoreValues: { large: 100, medium: 200, small: 500 },
                    splitTo: { large: 'medium', medium: 'small', small: null },
                    animFrames: mode.animFramesPerCharacter,
                    // Store for reference
                    fpsRatio: fpsRatio,
                    scale: scale,
                    // Mode limits (for HUD display)
                    maxBalls: mode.maxBallsOnScreen || 14,
                    maxHarpoons: mode.maxHarpoons || 2,
                    targetFPS: mode.targetFPS || 50,
                    spriteSystem: mode.spriteSystem || 'software'
                };
            },
            
            start(engine) { this.state = 'title'; },
            
            handleKeyPress(code, engine) {
                engine.audio.unlock();
                
                if (this.state === 'title' && ['Space', 'Enter', 'KeyZ'].includes(code)) {
                    this.startGame(engine);
                    return;
                }
                if (this.state === 'playing' && code === 'KeyP') {
                    engine.togglePause();
                    return;
                }
                if (code === 'Escape') {
                    this.returnToTitle(engine);
                    return;
                }
                if (this.state === 'levelCleared' && ['Space', 'Enter', 'KeyZ'].includes(code)) {
                    this.currentLevel++;
                    this.state = this.levels[this.currentLevel] ? 'playing' : 'cleared';
                    if (this.state === 'playing') this.spawnLevel(engine);
                    return;
                }
                if ((this.state === 'gameOver' || this.state === 'cleared') && code === 'KeyR') {
                    this.startGame(engine);
                    return;
                }
                if (this.state === 'timeout' && ['Space', 'Enter', 'KeyZ'].includes(code)) {
                    this.spawnLevel(engine);
                    this.state = 'playing';
                }
            },
            
            startGame(engine) {
                this.lives = 3;
                this.score = 0;
                this.currentLevel = 1;
                this.state = 'playing';
                // Set lastShotTime to now to prevent auto-fire on first frame
                this.lastShotTime = performance.now();
                engine.setPaused(false);
                this.spawnLevel(engine);
            },
            
            returnToTitle(engine) {
                this.state = 'title';
                engine.setPaused(false);
                this.balls = [];
                this.harpoons = [];
            },
            
            spawnLevel(engine) {
                this.balls = [];
                this.harpoons = [];
                const level = this.levels[this.currentLevel];
                if (!level) { this.state = 'cleared'; return; }
                
                // Set current background for this level
                this.currentBackground = level.background ? this.backgrounds[level.background] : null;
                
                this.levelTimer = level.timer;
                this.player.x = this.config.width / 2;
                // Position player so feet are on the floor (at floorY)
                this.player.y = this.config.floorY;
                this.player.facing = 0;  // Start facing forward
                this.player.isWalking = false;
                this.player.isShooting = false;
                this.player.shootTimer = 0;
                this.player.walkTimer = 0;
                // Reset shot timer to prevent auto-fire when level starts
                this.lastShotTime = performance.now();
                
                // Get mode-appropriate balls (CPC may have fewer due to sprite limits)
                const modeBalls = this.getModeBalls(level.balls, engine.mode);
                
                for (const b of modeBalls) {
                    const radius = this.config.ballRadius[b.size];
                    const speed = this.config.ballSpeed[b.size];
                    const x = this.config.playfieldLeft + radius + (this.config.playfieldWidth - radius * 2) * b.x;
                    const y = this.config.playfieldTop + radius + (this.config.playfieldHeight - radius * 2) * b.y;
                    this.balls.push({ x, y, vx: (b.dir || 1) * speed, vy: this.config.spawnVY, size: b.size, radius });
                }
            },
            
            loseLife(engine) {
                this.lives--;
                this.harpoons = [];
                if (this.lives <= 0) { this.state = 'gameOver'; }
                else { this.spawnLevel(engine); }
            },
            
            update(engine, dt) {
                if (this.state !== 'playing') return;
                
                this.levelTimer -= dt / 1000;
                if (this.levelTimer <= 0) {
                    this.levelTimer = 0;
                    this.state = 'timeout';
                    this.harpoons = [];
                    return;
                }
                
                // Player
                const input = engine.input;
                this.player.isWalking = input.isDown('left') || input.isDown('right');
                
                // Only update facing direction when actually walking
                // When shooting or idle, player faces forward (towards screen)
                if (input.isDown('left')) { 
                    this.player.x -= this.player.speed; 
                    this.player.facing = -1;
                    this.player.isShooting = false;
                }
                if (input.isDown('right')) { 
                    this.player.x += this.player.speed; 
                    this.player.facing = 1;
                    this.player.isShooting = false;
                }
                
                // When not walking, face forward (0 = facing screen)
                if (!this.player.isWalking) {
                    this.player.facing = 0;  // Forward facing (back to screen)
                }
                
                if (this.player.isWalking) {
                    this.player.walkTimer += 0.2;
                    this.player.bobOffset = Math.sin(this.player.walkTimer * 2);
                } else {
                    this.player.walkTimer = 0;
                    this.player.bobOffset = 0;
                }
                
                this.player.x = Math.max(this.config.playfieldLeft + this.player.width / 2,
                    Math.min(this.config.playfieldRight - this.player.width / 2, this.player.x));
                
                // Fire
                if (input.isDown('fire')) {
                    const now = performance.now();
                    if (now - this.lastShotTime > this.harpoonCooldown && engine.canSpawn('harpoon', this.harpoons.length)) {
                        // Harpoon starts from the floor and extends upward
                        // yBottom is fixed at floor, yTop extends up
                        this.harpoons.push({ 
                            x: this.player.x, 
                            yTop: this.config.floorY - 4,  // Start just above floor
                            yBottom: this.config.floorY - 2  // Bottom stays at floor
                        });
                        this.lastShotTime = now;
                        this.player.isShooting = true;
                        this.player.shootTimer = 10; // Frames to show shooting pose
                    }
                }
                
                // Decrease shoot timer
                if (this.player.shootTimer > 0) {
                    this.player.shootTimer--;
                    if (this.player.shootTimer <= 0) {
                        this.player.isShooting = false;
                    }
                }
                
                // Harpoons
                for (let i = this.harpoons.length - 1; i >= 0; i--) {
                    this.harpoons[i].yTop -= this.config.harpoonSpeed;
                    if (this.harpoons[i].yTop <= this.config.playfieldTop) this.harpoons.splice(i, 1);
                }
                
                // Balls
                for (const ball of this.balls) {
                    ball.vy += this.config.gravity;
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    
                    if (ball.x - ball.radius < this.config.playfieldLeft) { ball.x = this.config.playfieldLeft + ball.radius; ball.vx = Math.abs(ball.vx); }
                    if (ball.x + ball.radius > this.config.playfieldRight) { ball.x = this.config.playfieldRight - ball.radius; ball.vx = -Math.abs(ball.vx); }
                    if (ball.y - ball.radius < this.config.playfieldTop) { ball.y = this.config.playfieldTop + ball.radius; ball.vy = Math.abs(ball.vy); }
                    if (ball.y + ball.radius > this.config.floorY) { ball.y = this.config.floorY - ball.radius; ball.vy = this.config.bounceVY; }
                }
                
                // Collisions
                const pH = { x: this.player.x - this.player.width * 0.4, y: this.player.y - this.player.height * 0.45, width: this.player.width * 0.8, height: this.player.height * 0.9 };
                for (const ball of this.balls) {
                    if (this.rectCircle(pH, ball)) { this.loseLife(engine); return; }
                }
                
                for (let hi = this.harpoons.length - 1; hi >= 0; hi--) {
                    const h = this.harpoons[hi];
                    for (let bi = this.balls.length - 1; bi >= 0; bi--) {
                        const ball = this.balls[bi];
                        const hR = { x: h.x - this.config.harpoonBodyW / 2, y: h.yTop, width: this.config.harpoonBodyW, height: h.yBottom - h.yTop + this.config.harpoonHeadH };
                        if (this.rectCircle(hR, ball)) {
                            this.score += this.config.scoreValues[ball.size];
                            this.harpoons.splice(hi, 1);
                            this.balls.splice(bi, 1);
                            const next = this.config.splitTo[ball.size];
                            if (next && engine.canSpawn('ball', this.balls.length + 2)) {
                                const r = this.config.ballRadius[next];
                                const s = this.config.ballSpeed[next];
                                // Offset scaled to resolution
                                const splitOffset = 5 * (this.config.scale?.x || 1);
                                this.balls.push({ x: ball.x - splitOffset, y: ball.y, vx: -s, vy: this.config.spawnVY, size: next, radius: r });
                                this.balls.push({ x: ball.x + splitOffset, y: ball.y, vx: s, vy: this.config.spawnVY, size: next, radius: r });
                            }
                            break;
                        }
                    }
                }
                
                if (this.score > this.highScore) this.highScore = this.score;
                if (this.balls.length === 0 && this.state === 'playing') { this.state = 'levelCleared'; this.harpoons = []; }
            },
            
            rectCircle(r, c) {
                const dx = Math.abs(c.x - r.x - r.width / 2);
                const dy = Math.abs(c.y - r.y - r.height / 2);
                if (dx > r.width / 2 + c.radius || dy > r.height / 2 + c.radius) return false;
                if (dx <= r.width / 2 || dy <= r.height / 2) return true;
                return (dx - r.width / 2) ** 2 + (dy - r.height / 2) ** 2 <= c.radius ** 2;
            },
            
            render(engine) {
                const r = engine.renderer;
                const c = this.config;
                
                // Mode detection flags
                const isSpectrum = engine.mode.id === '8bit-basic';
                const is1Bit = engine.mode.id === '1bit';
                const isCPC = engine.mode.id === '8bit-cpc';
                const isPlus = engine.mode.id === '8bit-plus' || engine.mode.id === '8bit-gx4000';
                const isGX4000 = engine.mode.id === '8bit-gx4000';
                const isGenericPlus = engine.mode.id === '8bit-plus';
                const is16Bit = engine.mode.id === '16bit';
                
                // =============================================================
                // ZX SPECTRUM COLOUR PALETTE (Per RULES_8BIT_BASIC_MODE.md)
                // =============================================================
                // - Black background to avoid attribute clash
                // - Maximum 2 colours per 8x8 attribute cell
                // - Prefer BRIGHT colours for foreground elements
                // - Limit gameplay area to 2-4 total colours
                // =============================================================
                const spectrumColours = {
                    // Normal brightness
                    black: '#000000',
                    blue: '#0000D7',
                    red: '#D70000',
                    magenta: '#D700D7',
                    green: '#00D700',
                    cyan: '#00D7D7',
                    yellow: '#D7D700',
                    white: '#D7D7D7',
                    // Bright variants (preferred for foreground visibility)
                    brightBlue: '#0000FF',
                    brightRed: '#FF0000',
                    brightMagenta: '#FF00FF',
                    brightGreen: '#00FF00',
                    brightCyan: '#00FFFF',
                    brightYellow: '#FFFF00',
                    brightWhite: '#FFFFFF'
                };
                
                // =============================================================
                // AMSTRAD CPC COLOUR PALETTE (Per RULES_AMSTRAD_CPC.md)
                // =============================================================
                // - Only 27 FIXED colours (not 4096 like GX4000!)
                // - 3 levels per RGB channel: 0x00, 0x80, 0xFF
                // - NO attribute clash - colour is per-pixel
                // - Prefer flat fills, avoid excessive dithering
                // - "CPC looks best when it's clean, not busy"
                // =============================================================
                const cpcColours = {
                    // Core colors (from 27-color hardware palette)
                    black: '#000000',         // FW 0
                    blue: '#000080',          // FW 1
                    brightBlue: '#0000FF',    // FW 2
                    red: '#800000',           // FW 3
                    magenta: '#800080',       // FW 4
                    brightRed: '#FF0000',     // FW 6
                    brightMagenta: '#FF00FF', // FW 8
                    green: '#008000',         // FW 9
                    cyan: '#008080',          // FW 10
                    skyBlue: '#0080FF',       // FW 11
                    yellow: '#808000',        // FW 12
                    white: '#808080',         // FW 13 (actually grey)
                    orange: '#FF8000',        // FW 15
                    pink: '#FF8080',          // FW 16
                    brightGreen: '#00FF00',   // FW 18
                    seaGreen: '#00FF80',      // FW 19
                    brightCyan: '#00FFFF',    // FW 20
                    lime: '#80FF00',          // FW 21
                    pastelGreen: '#80FF80',   // FW 22
                    brightYellow: '#FFFF00',  // FW 24
                    pastelYellow: '#FFFF80',  // FW 25
                    brightWhite: '#FFFFFF'    // FW 26
                };
                
                // CPC 27-color lookup for palette snapping
                const CPC_27_PALETTE = [
                    '#000000', '#000080', '#0000FF', '#800000', '#800080', '#8000FF',
                    '#FF0000', '#FF0080', '#FF00FF', '#008000', '#008080', '#0080FF',
                    '#808000', '#808080', '#8080FF', '#FF8000', '#FF8080', '#FF80FF',
                    '#00FF00', '#00FF80', '#00FFFF', '#80FF00', '#80FF80', '#80FFFF',
                    '#FFFF00', '#FFFF80', '#FFFFFF'
                ];
                
                // =============================================================
                // CPC PLUS COLOUR PALETTE (Per RULES_8BIT_PLUS_MODE.md)
                // =============================================================
                // - 4096 colours (12-bit RGB)
                // - 16 hardware sprites with 15-colour sprite palette
                // - Background still software-rendered
                // - "Plus should feel RICHER, not fundamentally different"
                // Based on authentic GX4000 Pang screenshot
                // =============================================================
                const plusColours = {
                    // Basic colours (12-bit RGB)
                    black: '#000000',
                    blue: '#0044AA',
                    brightBlue: '#0088FF',
                    red: '#AA2200',
                    brightRed: '#FF4400',
                    green: '#00AA44',
                    brightGreen: '#00FF66',
                    cyan: '#00AAAA',
                    brightCyan: '#00FFFF',
                    yellow: '#AAAA00',
                    brightYellow: '#FFFF00',
                    orange: '#FF8800',
                    white: '#AAAAAA',
                    brightWhite: '#FFFFFF',
                    
                    // Sky gradient (light blue to medium blue)
                    skyLight: '#88CCFF',
                    skyMedium: '#6699DD',
                    skyDark: '#4477BB',
                    
                    // Mountain colours (greys with slight purple tint)
                    mountainWhite: '#FFFFFF',    // Snow cap
                    mountainLight: '#CCCCDD',    // Light snow
                    mountainMedium: '#9999AA',   // Rock
                    mountainDark: '#666688',     // Shadow
                    mountainPurple: '#887799',   // Atmospheric
                    
                    // Ground/vegetation colours
                    groundDark: '#334433',       // Dark ground
                    groundMedium: '#556655',     // Medium ground  
                    groundLight: '#778877',      // Light ground
                    forestDark: '#224422',       // Dark trees
                    forestMedium: '#336633',     // Medium trees
                    forestLight: '#448844',      // Light trees
                    grassGreen: '#66AA66',       // Grass
                    
                    // Brown/earth tones
                    brownDark: '#553311',        // Dark brown
                    brownMedium: '#775533',      // Medium brown
                    brownLight: '#997755',       // Light brown
                    
                    // Atmospheric/mist
                    mistLight: '#AABBCC',        // Light mist
                    mistMedium: '#8899AA',       // Medium mist
                    mistDark: '#667788',         // Dark mist
                    
                    // Ball colours (red gradient with highlight)
                    ballRed: '#DD2200',          // Main ball colour
                    ballOrange: '#FF6600',       // Ball mid-tone
                    ballYellow: '#FFAA44',       // Ball highlight
                    ballDark: '#881100',         // Ball shadow
                    
                    // Player colours
                    skinTone: '#FFAA88',
                    hairBrown: '#553322',
                    clothBlue: '#4466AA',
                    clothLight: '#6688CC',
                    
                    // Harpoon
                    harpoonWhite: '#FFFFFF',
                    harpoonCyan: '#88DDFF',
                    
                    // Border (brick pattern)
                    brickGrey: '#888899',
                    brickDark: '#555566',
                    brickLight: '#AAAAAA',
                    
                    // HUD
                    hudBlack: '#000000',
                    hudWhite: '#FFFFFF',
                    hudYellow: '#FFDD00',
                    hudRed: '#FF4444',
                    hudCyan: '#44DDFF'
                };
                
                // =============================================================
                // GX4000 AUTHENTIC COLOUR PALETTE (Per RULES_AMSTRAD_CPC.md)
                // =============================================================
                // CPC Plus/GX4000: 4096 colours (12-bit RGB)
                // Each channel: 4 bits (16 levels: 0x0-0xF)
                // Hex format: #RGB where R,G,B are 0-F (expanded to #RRGGBB)
                // All values snapped to 12-bit: 0x00,0x11,0x22...0xEE,0xFF
                // =============================================================
                
                // Helper to snap color to 12-bit (4 bits per channel)
                const snap12bit = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    // Snap to 16 levels (0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255)
                    const snap = (v) => Math.round(v / 17) * 17;
                    const rs = snap(r).toString(16).padStart(2, '0');
                    const gs = snap(g).toString(16).padStart(2, '0');
                    const bs = snap(b).toString(16).padStart(2, '0');
                    return `#${rs}${gs}${bs}`;
                };
                
                const gx4000Colours = {
                    // Core (pure values in 12-bit)
                    black: '#000000',         // 0x000
                    white: '#FFFFFF',         // 0xFFF
                    
                    // Sky - flat color (authentic Mode 0 look)
                    sky: snap12bit('#99BBDD'),           // Light blue-grey -> #99BBDD
                    
                    // Mountain (authentic blocky look)
                    mountainWhite: '#FFFFFF',  // Snow cap - pure white
                    mountainLight: snap12bit('#CCCCDD'),  // Light snow/rock
                    mountainGrey: snap12bit('#9999AA'),   // Rock body
                    mountainDark: snap12bit('#666677'),   // Shadow areas
                    
                    // Atmospheric bands (horizontal layers - key GX4000 visual)
                    atmosLight: snap12bit('#8899AA'),     // Light atmospheric
                    atmosMedium: snap12bit('#667788'),    // Medium
                    atmosDark: snap12bit('#556677'),      // Dark
                    
                    // Ground/vegetation (horizontal bands - authentic Mode 0)
                    groundDark: snap12bit('#334444'),     // Dark ground
                    groundMedium: snap12bit('#445555'),   // Medium ground
                    vegDark: snap12bit('#335544'),        // Dark vegetation
                    vegMedium: snap12bit('#446655'),      // Medium vegetation
                    vegLight: snap12bit('#558866'),       // Light vegetation
                    
                    // Tree/trunk (blocky pixel art style)
                    treeDark: snap12bit('#443322'),       // Dark brown tree
                    treeLight: snap12bit('#554433'),      // Light brown
                    
                    // Ball (authentic red-orange-yellow bands)
                    // GX4000 balls have distinct color bands, not smooth gradients
                    ballRed: snap12bit('#CC2200'),        // Deep red (bottom)
                    ballOrange: snap12bit('#EE6600'),     // Orange (middle)
                    ballYellow: snap12bit('#FFAA33'),     // Yellow (top highlight)
                    
                    // Player sprite (authentic GX4000 Pang character)
                    skinTone: snap12bit('#DDAA88'),       // Face/hands
                    hairBrown: snap12bit('#443322'),      // Hair/hat
                    clothBeige: snap12bit('#AA8866'),     // Shirt/jacket
                    clothDark: snap12bit('#665544'),      // Pants/shoes
                    
                    // Harpoon (white zigzag rope)
                    harpoonWhite: '#FFFFFF',              // Pure white
                    harpoonLight: snap12bit('#CCDDEE'),   // Light for anti-alias
                    
                    // Border - PURPLE/LAVENDER (authentic GX4000 Pang!)
                    // This is a key visual identifier of GX4000 version
                    borderLight: snap12bit('#8877AA'),    // Light purple highlight
                    borderMedium: snap12bit('#665588'),   // Medium purple body
                    borderDark: snap12bit('#554477'),     // Dark purple shadow
                    
                    // HUD (score, lives, timer)
                    hudWhite: '#FFFFFF',
                    hudYellow: snap12bit('#FFCC00'),      // Score
                    hudRed: snap12bit('#FF4444')          // Timer warning
                };
                
                // =============================================================
                // CPC HARDWARE PALETTE REFERENCE (for export)
                // Firmware colour (0-26) -> Hardware colour (0x00-0x1F)
                // =============================================================
                const CPC_HW_COLOURS = {
                    0:  0x14,  // Black
                    1:  0x04,  // Blue
                    2:  0x15,  // Bright Blue
                    3:  0x1C,  // Red
                    4:  0x18,  // Magenta
                    5:  0x1D,  // Mauve
                    6:  0x0C,  // Bright Red
                    7:  0x05,  // Purple
                    8:  0x0D,  // Bright Magenta
                    9:  0x16,  // Green
                    10: 0x06,  // Cyan
                    11: 0x17,  // Sky Blue
                    12: 0x1E,  // Yellow
                    13: 0x00,  // White
                    14: 0x1F,  // Pastel Blue
                    15: 0x0E,  // Orange
                    16: 0x07,  // Pink
                    17: 0x0F,  // Pastel Magenta
                    18: 0x12,  // Bright Green
                    19: 0x02,  // Sea Green
                    20: 0x13,  // Bright Cyan
                    21: 0x1A,  // Lime
                    22: 0x19,  // Pastel Green
                    23: 0x1B,  // Pastel Cyan
                    24: 0x0A,  // Bright Yellow
                    25: 0x03,  // Pastel Yellow
                    26: 0x0B   // Bright White
                };
                
                // =============================================================
                // 16-BIT COLOUR PALETTE (Per RULES_16BIT_MODE.md)
                // =============================================================
                // - 512 colours total (9-bit RGB: 3 bits per channel)
                // - 64 on-screen max (4 palettes × 16)
                // - UI uses max 4 colours
                // - No true alpha blending
                // - All values snapped to 8 levels per channel (0,36,73,109,146,182,219,255)
                // =============================================================
                const mdColours = {
                    // Basic colours (snapped to 9-bit)
                    black: '#000000',
                    darkBlue: '#000049',
                    blue: '#000092',
                    brightBlue: '#0000ff',
                    darkRed: '#490000',
                    red: '#920000',
                    brightRed: '#ff0000',
                    darkGreen: '#004900',
                    green: '#009200',
                    brightGreen: '#00ff00',
                    darkCyan: '#004949',
                    cyan: '#009292',
                    brightCyan: '#00ffff',
                    darkYellow: '#494900',
                    yellow: '#929200',
                    brightYellow: '#ffff00',
                    orange: '#ff9200',
                    brightOrange: '#ffdb00',
                    // Greys (snapped)
                    darkGrey: '#242424',
                    grey: '#494949',
                    midGrey: '#6d6d6d',
                    lightGrey: '#929292',
                    brightGrey: '#b6b6b6',
                    white: '#dbdbdb',
                    brightWhite: '#ffffff',
                    // Game-specific (Pang palette)
                    skyBlue: '#4992ff',
                    groundBrown: '#926d24',
                    playerCyan: '#00dbdb',
                    ballRed: '#ff2424',
                    ballOrange: '#ff6d49',
                    ballYellow: '#ffb66d',
                    harpoonYellow: '#ffdb00',
                    harpoonOrange: '#db9200'
                };
                
                // =============================================================
                // TITLE SCREEN
                // Mode-specific colours per respective RULES documents
                // =============================================================
                if (this.state === 'title') {
                    let titleBg, titleColour, subColour, textColour, hintColour;
                    
                    if (is1Bit) {
                        // Per RULES_1BIT_MODE.md Rule 6: Strong contrast, black/white only
                        titleBg = '#000000';
                        titleColour = '#FFFFFF';
                        subColour = '#FFFFFF';
                        textColour = '#FFFFFF';
                        hintColour = '#FFFFFF';
                    } else if (isSpectrum) {
                        // Per RULES_8BIT_BASIC_MODE.md Rule 5: Black background
                        titleBg = '#000000';
                        titleColour = spectrumColours.brightYellow;
                        subColour = spectrumColours.cyan;
                        textColour = spectrumColours.brightWhite;
                        hintColour = spectrumColours.green;
                    } else if (isCPC) {
                        // Per RULES_8BIT_CPC_MODE.md Rule 4: Clean, flat fills
                        titleBg = '#000000';
                        titleColour = cpcColours.brightYellow;
                        subColour = cpcColours.skyBlue;
                        textColour = cpcColours.brightWhite;
                        hintColour = cpcColours.cyan;
                    } else if (isPlus) {
                        // Per RULES_8BIT_PLUS_MODE.md Rule 4: Richer palette
                        titleBg = '#000011';
                        titleColour = plusColours.brightYellow;
                        subColour = plusColours.skyBlue;
                        textColour = plusColours.brightWhite;
                        hintColour = plusColours.cyan;
                    } else {
                        // 16-Bit: Per RULES_16BIT_MODE.md
                        // Colours snapped to 9-bit RGB (512 palette)
                        // UI uses max 4 colours per Rule 2
                        titleBg = '#000024';   // Dark blue (snapped)
                        titleColour = '#ffdb00'; // Yellow (snapped to MD palette)
                        subColour = '#929292';   // Grey (snapped)
                        textColour = '#ffffff';  // White
                        hintColour = '#6d6d6d';  // Dark grey (snapped)
                    }
                    
                    r.clear(titleBg);
                    r.drawText('PANG!', c.width / 2, c.height / 2 - 30, { colour: titleColour, font: 'bold 24px monospace', align: 'center', baseline: 'middle' });
                    r.drawText(`Mode: ${engine.mode.name}`, c.width / 2, c.height / 2, { colour: subColour, font: '10px monospace', align: 'center', baseline: 'middle' });
                    if (Math.floor(performance.now() / 500) % 2 === 0) {
                        r.drawText('PRESS FIRE TO START', c.width / 2, c.height / 2 + 30, { colour: textColour, font: '10px monospace', align: 'center', baseline: 'middle' });
                    }
                    r.drawText('ARROWS = Move | SPACE = Fire | P = Pause', c.width / 2, c.height - 15, { colour: hintColour, font: '8px monospace', align: 'center', baseline: 'middle' });
                    return;
                }
                
                r.clear('#000');
                
                // =============================================================
                // BACKGROUND
                // =============================================================
                // ZX Spectrum Pang uses BRIGHT BLUE background with WHITE sprites
                // This is the authentic look from the Ocean 1990 port
                // =============================================================
                
                if (isSpectrum) {
                    // Per RULES_8BIT_BASIC_MODE.md: Blue background, white sprites
                    // Fill entire playfield with bright blue first
                    r.drawRect(c.playfieldLeft, c.playfieldTop, c.playfieldWidth, c.playfieldHeight, spectrumColours.brightBlue, 'background');
                    
                    // Draw software background with WHITE ink on BLUE paper
                    if (this.currentBackground && this.currentBackground.type === 'software') {
                        r.drawSoftwareBackground(
                            this.currentBackground.def,
                            { x: c.playfieldLeft, y: c.playfieldTop, width: c.playfieldWidth, height: c.playfieldHeight },
                            spectrumColours.brightWhite,  // White dithering (ink)
                            spectrumColours.brightBlue    // Blue background (paper)
                        );
                    }
                } else if (is1Bit) {
                    // 1-Bit: Black background, white sprites
                    r.drawRect(c.playfieldLeft, c.playfieldTop, c.playfieldWidth, c.playfieldHeight, '#000000', 'background');
                    if (this.currentBackground && this.currentBackground.type === 'software') {
                        r.drawSoftwareBackground(
                            this.currentBackground.def,
                            { x: c.playfieldLeft, y: c.playfieldTop, width: c.playfieldWidth, height: c.playfieldHeight },
                            '#FFFFFF',  // White dithering (ink)
                            '#000000'   // Black background (paper)
                        );
                    }
                } else if (isGX4000) {
                    // =============================================================
                    // 8-BIT GX4000 - AUTHENTIC MODE 0 BACKGROUND
                    // Per RULES_8BIT_GX4000_MODE.md: 16 colors, no gradients
                    // Uses dithering, solid color bands, authentic palette
                    // =============================================================
                    this.drawGX4000Background(r, c, gx4000Colours);
                } else if (isGenericPlus) {
                    // =============================================================
                    // 8-BIT PLUS (GENERIC) - COLORFUL BACKGROUND
                    // Artistic interpretation with smooth gradients
                    // =============================================================
                    this.drawPlusBackground(r, c, plusColours);
                } else if (isCPC) {
                    // =============================================================
                    // 8-BIT CPC CLASSIC - SIMPLER THAN GX4000
                    // Per CPCtelera: Software sprites, 27 colors, 25fps
                    // "If it wouldn't run on CPC 464 from tape, it's too fancy"
                    // =============================================================
                    this.drawCPCBackground(r, c, cpcColours);
                } else if (this.currentBackground) {
                    // Other modes with backgrounds
                    r.drawRect(c.playfieldLeft, c.playfieldTop, c.playfieldWidth, c.playfieldHeight, '#000000', 'background');
                    if (this.currentBackground.type === 'image' && this.currentBackground.img) {
                        r.drawBackgroundImage(this.currentBackground.img, c.playfieldLeft, c.playfieldTop, c.playfieldWidth, c.playfieldHeight);
                    }
                } else {
                    // Fallback backgrounds (16-bit)
                    this.draw16BitBackground(r, c, mdColours);
                }
                
                // =============================================================
                // BORDER / FRAME
                // Spectrum Pang has a distinctive brick pattern border
                // =============================================================
                
                if (isSpectrum) {
                    // Draw brick pattern border (authentic Spectrum Pang style)
                    this.drawSpectrumBrickBorder(r, c, spectrumColours);
                } else if (isGX4000) {
                    // Draw authentic GX4000 brick border
                    this.drawGX4000BrickBorder(r, c, gx4000Colours);
                } else if (isGenericPlus) {
                    // Draw colorful brick border for Generic Plus mode
                    this.drawPlusBrickBorder(r, c, plusColours);
                } else if (isCPC) {
                    // CPC: Blue brick border (simpler than GX4000's purple 3D bricks)
                    this.drawCPCBrickBorder(r, c, cpcColours);
                } else {
                    // Other modes: solid colour border
                    let borderColour;
                    if (is1Bit) {
                        borderColour = '#FFFFFF';
                    } else {
                        borderColour = mdColours.darkBlue;
                    }
                    
                    r.drawRect(0, 0, c.width, c.borderSize, borderColour, 'foreground');
                    r.drawRect(0, 0, c.borderSize, c.floorY + c.borderSize, borderColour, 'foreground');
                    r.drawRect(c.width - c.borderSize, 0, c.borderSize, c.floorY + c.borderSize, borderColour, 'foreground');
                    r.drawRect(c.borderSize, c.floorY, c.width - c.borderSize * 2, c.borderSize, borderColour, 'foreground');
                }
                
                // =============================================================
                // PLAYER
                // Mode-specific rendering per respective RULES documents
                // Spectrum: White sprite on blue background
                // =============================================================
                const p = this.player;
                const px = p.x - p.width / 2;
                const py = p.y - p.height / 2 + p.bobOffset;
                const ps = engine.sprites.get('player');
                
                if (ps && ps.type !== 'placeholder') {
                    const anim = p.isWalking ? 'walk' : 'idle';
                    r.drawSprite(ps, anim, Math.floor(p.walkTimer) % c.animFrames, px, py, { flipX: p.facing === -1 });
                } else {
                    // Player fallback - draw character based on mode
                    let playerColour;
                    
                    if (is1Bit || isSpectrum) {
                        playerColour = '#FFFFFF';
                    } else if (isCPC) {
                        playerColour = cpcColours.brightCyan;
                    } else if (isPlus) {
                        playerColour = plusColours.brightCyan;
                    } else {
                        playerColour = mdColours.playerCyan;
                    }
                    
                    if (is1Bit || isSpectrum) {
                        // Draw detailed pixel character matching the Spectrum Pang screenshot
                        // Character is white on blue background
                        this.drawSpectrumPlayer(r, p, playerColour, c);
                    } else if (isGX4000) {
                        // Draw authentic GX4000 player (hardware sprite, multi-color)
                        this.drawGX4000Player(r, p, gx4000Colours, c);
                    } else if (isCPC) {
                        // Draw simpler CPC player (software sprite, fewer colors)
                        this.drawCPCPlayer(r, p, cpcColours, c);
                    } else if (isGenericPlus) {
                        // Draw colorful multi-color player for Generic Plus mode
                        this.drawPlusPlayer(r, p, plusColours, c);
                    } else {
                        // Other modes: rectangle fallback
                        r.drawRect(px, py, p.width, p.height, playerColour, 'foreground');
                    }
                }
                
                // =============================================================
                // HARPOONS
                // Spectrum: Wavy/zigzag pattern (authentic to the original)
                // =============================================================
                let harpoonColour, harpoonBodyColour;
                
                if (is1Bit || isSpectrum) {
                    // Per RULES_8BIT_BASIC_MODE.md: WHITE harpoon on blue
                    harpoonColour = '#FFFFFF';
                    harpoonBodyColour = '#FFFFFF';
                } else if (isCPC) {
                    harpoonColour = cpcColours.brightYellow;
                    harpoonBodyColour = cpcColours.yellow;
                } else if (isPlus) {
                    harpoonColour = plusColours.brightYellow;
                    harpoonBodyColour = plusColours.orange;
                } else {
                    harpoonColour = mdColours.harpoonYellow;
                    harpoonBodyColour = mdColours.harpoonOrange;
                }
                
                for (const h of this.harpoons) {
                    if (is1Bit || isSpectrum) {
                        // Draw wavy/zigzag harpoon pattern (authentic Spectrum Pang style)
                        // This creates the distinctive "rope" or "chain" visual effect
                        this.drawWavyHarpoon(r, h, harpoonColour, c);
                    } else if (isGX4000) {
                        // GX4000: wavy harpoon with authentic 2-color palette
                        this.drawGX4000WavyHarpoon(r, h, gx4000Colours, c);
                    } else if (isCPC) {
                        // CPC: simpler zigzag (fewer CPU cycles)
                        this.drawCPCWavyHarpoon(r, h, cpcColours, c);
                    } else if (isGenericPlus) {
                        // Generic Plus: wavy harpoon with cyan/white coloring
                        this.drawPlusWavyHarpoon(r, h, plusColours, c);
                    } else {
                        // Other modes: standard harpoon
                        const bodyW = Math.max(2, c.harpoonBodyW / 2);
                        const headW = Math.max(6, c.harpoonBodyW * 1.5);
                        const headH = Math.max(8, c.harpoonHeadH * 0.8);
                        
                        r.drawRect(h.x - bodyW, h.yTop + headH, bodyW * 2, h.yBottom - h.yTop - headH, harpoonBodyColour, 'foreground');
                        r.drawRect(h.x - headW / 2, h.yTop, headW, headH, harpoonColour, 'foreground');
                    }
                }
                
                // =============================================================
                // BALLS
                // Spectrum: Outlined circles with dithered interior (authentic style)
                // All balls are WHITE on blue background
                // =============================================================
                let ballColours;
                
                if (is1Bit || isSpectrum) {
                    // Per RULES_8BIT_BASIC_MODE.md: All balls WHITE
                    // The authentic Spectrum Pang has white outlined balls with dithered interiors
                    ballColours = { large: '#FFFFFF', medium: '#FFFFFF', small: '#FFFFFF' };
                } else if (isCPC) {
                    ballColours = { 
                        large: cpcColours.brightRed, 
                        medium: cpcColours.orange, 
                        small: cpcColours.brightYellow 
                    };
                } else if (isPlus) {
                    ballColours = { 
                        large: plusColours.brightRed, 
                        medium: plusColours.orange, 
                        small: plusColours.brightYellow 
                    };
                } else {
                    // 16-Bit: Per RULES_16BIT_MODE.md - snapped to 9-bit palette
                    ballColours = { 
                        large: mdColours.ballRed, 
                        medium: mdColours.ballOrange, 
                        small: mdColours.ballYellow 
                    };
                }
                
                for (const b of this.balls) {
                    if (is1Bit) {
                        // Per RULES_1BIT_MODE.md Rule 5: Solid white with black outline
                        r.drawCircle(b.x, b.y, b.radius + 1, '#000000', 'foreground');
                        r.drawCircle(b.x, b.y, b.radius, '#FFFFFF', 'foreground');
                    } else if (isSpectrum) {
                        // Per RULES_8BIT_BASIC_MODE.md: Outlined ball with dithered interior
                        // This matches the authentic Spectrum Pang visual style
                        this.drawSpectrumBall(r, b, spectrumColours);
                    } else if (isCPC) {
                        // Per CPCtelera: Software sprites are expensive
                        // Simpler ball with flat color (no gradient bands)
                        this.drawCPCBall(r, b, cpcColours);
                    } else if (isGX4000) {
                        // Per RULES_8BIT_GX4000_MODE.md: Dithered 3-color ball
                        // Authentic GX4000 style with hard pixel edges
                        this.drawGX4000Ball(r, b, gx4000Colours);
                    } else if (isGenericPlus) {
                        // Generic Plus: Smooth gradient ball
                        this.drawPlusBall(r, b, plusColours);
                    } else {
                        // 16-Bit: Per RULES_16BIT_MODE.md Rule 3: No true alpha blending
                        // Use solid highlight colour instead of alpha (hardware shadow/highlight mode)
                        r.drawCircle(b.x, b.y, b.radius, ballColours[b.size], 'foreground');
                        // Solid highlight (simulating MD shadow/highlight mode)
                        r.drawCircle(b.x - b.radius * 0.3, b.y - b.radius * 0.3, b.radius * 0.25, '#ffdbdb');
                    }
                }
                
                // =============================================================
                // HUD
                // Spectrum: Authentic layout matching Ocean 1990 port
                // =============================================================
                const hudY = c.floorY + c.borderSize;
                r.drawRect(0, hudY, c.width, c.hudHeight, '#000', 'background');
                
                const time = Math.max(0, Math.ceil(this.levelTimer));
                const level = this.levels[this.currentLevel];
                const stageName = level?.name || 'LEVEL';
                const stageNum = level?.stage || `${this.currentLevel}`;
                
                if (isSpectrum) {
                    // Authentic Spectrum Pang HUD layout:
                    // PLAYER-1    1:38    MT FUJI    PLAYER-2
                    // 000500                         000000
                    // ████    1-1 STAGE  HIT FIRE
                    // ████  HIGH SCORE- 100000
                    
                    const white = spectrumColours.brightWhite;
                    const yellow = spectrumColours.brightYellow;
                    
                    // Row 1: Player labels and timer
                    r.drawText('PLAYER-1', 4, hudY + 2, { colour: white, font: '8px monospace' });
                    const timeMin = Math.floor(time / 60);
                    const timeSec = time % 60;
                    const timeStr = `${timeMin}:${String(timeSec).padStart(2, '0')}`;
                    r.drawText(timeStr, c.width / 2, hudY + 2, { colour: white, font: '8px monospace', align: 'center' });
                    r.drawText(stageName, c.width / 2, hudY + 12, { colour: white, font: '8px monospace', align: 'center' });
                    r.drawText('PLAYER-2', c.width - 4, hudY + 2, { colour: white, font: '8px monospace', align: 'right' });
                    
                    // Row 2: Scores
                    r.drawText(String(this.score).padStart(6, '0'), 4, hudY + 12, { colour: yellow, font: '8px monospace' });
                    r.drawText('000000', c.width - 4, hudY + 12, { colour: white, font: '8px monospace', align: 'right' });
                    
                    // Row 3: Lives indicator and stage
                    // Draw lives as small blocks
                    for (let i = 0; i < this.lives; i++) {
                        r.drawRect(4 + i * 8, hudY + 22, 6, 8, yellow, 'foreground');
                    }
                    r.drawText(`${stageNum} STAGE`, c.width / 2 - 20, hudY + 24, { colour: white, font: '8px monospace' });
                    r.drawText('HIT FIRE', c.width - 4, hudY + 24, { colour: white, font: '8px monospace', align: 'right' });
                    
                    // Row 4: High score
                    r.drawText('HIGH SCORE-', c.width / 2 - 30, hudY + 34, { colour: white, font: '8px monospace' });
                    r.drawText(String(this.highScore).padStart(6, '0'), c.width / 2 + 50, hudY + 34, { colour: yellow, font: '8px monospace' });
                } else {
                    // Standard HUD for other modes
                    let hudLabelColour, hudValueColour, hudScoreColour, hudDangerColour;
                    
                    if (is1Bit) {
                        hudLabelColour = '#FFFFFF';
                        hudValueColour = '#FFFFFF';
                        hudScoreColour = '#FFFFFF';
                        hudDangerColour = '#FFFFFF';
                    } else if (isCPC) {
                        hudLabelColour = cpcColours.skyBlue;
                        hudValueColour = cpcColours.brightWhite;
                        hudScoreColour = cpcColours.brightGreen;
                        hudDangerColour = cpcColours.brightRed;
                    } else if (isPlus) {
                        hudLabelColour = plusColours.skyBlue;
                        hudValueColour = plusColours.brightWhite;
                        hudScoreColour = plusColours.brightGreen;
                        hudDangerColour = plusColours.brightRed;
                    } else {
                        hudLabelColour = mdColours.cyan;
                        hudValueColour = mdColours.brightWhite;
                        hudScoreColour = mdColours.brightWhite;
                        hudDangerColour = mdColours.brightRed;
                    }
                    
                    r.drawText('SCORE', 8, hudY + 4, { colour: hudLabelColour, font: '8px monospace' });
                    r.drawText(String(this.score).padStart(6, '0'), 8, hudY + 14, { colour: hudScoreColour, font: '8px monospace' });
                    r.drawText(`${stageName}`, c.width / 2, hudY + 8, { colour: hudValueColour, font: '8px monospace', align: 'center' });
                    r.drawText(`${stageNum} STAGE`, c.width / 2, hudY + 18, { colour: hudValueColour, font: '8px monospace', align: 'center' });
                    r.drawText(`LIVES: ${this.lives}`, 8, hudY + 28, { colour: hudValueColour, font: '8px monospace' });
                    
                    // Show mode-specific hardware info (CPC vs GX4000 differences)
                    if (isCPC || isGX4000) {
                        const hwInfo = isCPC ? `${c.targetFPS}fps SW` : `${c.targetFPS}fps HW`;
                        r.drawText(hwInfo, 8, hudY + 38, { colour: hudLabelColour, font: '6px monospace' });
                    }
                    
                    const timeColour = time <= 10 ? hudDangerColour : hudValueColour;
                    const showTimer = is1Bit && time <= 10 ? (Math.floor(performance.now() / 250) % 2 === 0) : true;
                    if (showTimer) {
                        r.drawText(`TIME ${String(time).padStart(3, '0')}`, c.width - 8, hudY + 4, { colour: timeColour, font: '8px monospace', align: 'right' });
                    }
                    r.drawText(`HI ${String(this.highScore).padStart(6, '0')}`, c.width - 8, hudY + 28, { colour: hudLabelColour, font: '8px monospace', align: 'right' });
                }
                
                // =============================================================
                // OVERLAYS (Pause, Game Over, etc.)
                // Mode-specific rendering per respective RULES documents
                // =============================================================
                let overlayColours;
                
                if (is1Bit) {
                    // Per RULES_1BIT_MODE.md: All white on black
                    overlayColours = {
                        paused: '#FFFFFF', cleared: '#FFFFFF', timeout: '#FFFFFF',
                        gameOver: '#FFFFFF', win: '#FFFFFF'
                    };
                } else if (isSpectrum) {
                    // Per RULES_8BIT_BASIC_MODE.md: Bright Spectrum colours
                    overlayColours = {
                        paused: spectrumColours.brightYellow,
                        cleared: spectrumColours.brightGreen,
                        timeout: spectrumColours.brightRed,
                        gameOver: spectrumColours.brightRed,
                        win: spectrumColours.brightCyan
                    };
                } else if (isCPC) {
                    // Per RULES_8BIT_CPC_MODE.md: Clean CPC colours
                    overlayColours = {
                        paused: cpcColours.brightYellow,
                        cleared: cpcColours.brightGreen,
                        timeout: cpcColours.brightRed,
                        gameOver: cpcColours.brightRed,
                        win: cpcColours.brightCyan
                    };
                } else if (isPlus) {
                    // Per RULES_8BIT_PLUS_MODE.md: Richer Plus colours
                    overlayColours = {
                        paused: plusColours.brightYellow,
                        cleared: plusColours.brightGreen,
                        timeout: plusColours.brightRed,
                        gameOver: plusColours.brightRed,
                        win: plusColours.brightCyan
                    };
                } else {
                    // 16-Bit: Per RULES_16BIT_MODE.md - snapped to 9-bit palette
                    overlayColours = {
                        paused: mdColours.brightYellow,
                        cleared: mdColours.brightGreen,
                        timeout: mdColours.brightRed,
                        gameOver: mdColours.brightRed,
                        win: mdColours.brightCyan
                    };
                }
                
                // Pass mode flags to overlay function
                const modeFlags = { is1Bit, isSpectrum, isCPC, isPlus, is16Bit };
                
                if (engine.paused) this.overlay(r, c, 'PAUSED', overlayColours.paused, null, modeFlags);
                else if (this.state === 'levelCleared') this.overlay(r, c, `LEVEL ${this.currentLevel} CLEARED!`, overlayColours.cleared, 'Press FIRE', modeFlags);
                else if (this.state === 'timeout') this.overlay(r, c, 'TIME OUT!', overlayColours.timeout, 'Press FIRE', modeFlags);
                else if (this.state === 'gameOver') this.overlay(r, c, 'GAME OVER', overlayColours.gameOver, 'Press R', modeFlags);
                else if (this.state === 'cleared') this.overlay(r, c, 'YOU WIN!', overlayColours.win, `Score: ${this.score}`, modeFlags);
            },
            
            overlay(r, c, title, colour, sub, modeFlags = {}) {
                const { is1Bit, isSpectrum, isCPC, isPlus, is16Bit } = modeFlags;
                
                // Overlay background
                // Per respective RULES: ALL modes use solid colours (no alpha)
                // 16-Bit: Per RULES_16BIT_MODE.md Rule 3: No true alpha blending
                if (is1Bit || isSpectrum || isCPC) {
                    r.drawRect(0, 0, c.width, c.height, '#000000');
                } else if (isPlus) {
                    // Plus: Solid colour
                    r.drawRect(0, 0, c.width, c.height, '#000011');
                } else if (is16Bit) {
                    // 16-Bit: Per RULES_16BIT_MODE.md Rule 3: No true alpha
                    // Use solid dark colour (snapped to 9-bit palette)
                    r.drawRect(0, 0, c.width, c.height, '#000024');
                } else {
                    // Fallback: solid black
                    r.drawRect(0, 0, c.width, c.height, '#000000');
                }
                
                // Title colour
                const titleColour = is1Bit ? '#FFFFFF' : colour;
                r.drawText(title, c.width / 2, c.height / 2 - 10, { colour: titleColour, font: 'bold 16px monospace', align: 'center', baseline: 'middle' });
                
                // Sub text colour - Per RULES_16BIT_MODE.md Rule 2: UI uses max 4 colours
                let subColour;
                if (is1Bit) {
                    subColour = '#FFFFFF';
                } else if (isSpectrum) {
                    subColour = '#D7D7D7';
                } else if (isCPC) {
                    subColour = '#808080';
                } else if (isPlus) {
                    subColour = '#AAAAAA';
                } else if (is16Bit) {
                    // 16-Bit: Snapped to 9-bit palette
                    subColour = '#929292';
                } else {
                    subColour = '#aaa';
                }
                
                if (sub) r.drawText(sub, c.width / 2, c.height / 2 + 15, { colour: subColour, font: '10px monospace', align: 'center', baseline: 'middle' });
            },
            
            // =================================================================
            // SPECTRUM-SPECIFIC RENDERING METHODS
            // These create the authentic ZX Spectrum Pang visual style
            // =================================================================
            
            // Draw the brick pattern border (authentic Spectrum Pang style)
            drawSpectrumBrickBorder(r, c, colours) {
                const brickW = 8;  // Brick width
                const brickH = 4;  // Brick height
                const borderSize = c.borderSize;
                
                // Fill border areas with base colour first
                r.ctx.fillStyle = colours.white;
                
                // Top border
                for (let y = 0; y < borderSize; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        // Alternate brick pattern
                        const brickX = x + offset;
                        if (brickX < c.width) {
                            // Draw brick with mortar lines
                            r.ctx.fillStyle = colours.white;
                            r.ctx.fillRect(brickX, y, brickW - 1, brickH - 1);
                        }
                    }
                }
                
                // Bottom border (above HUD) - same pattern
                for (let y = c.floorY; y < c.floorY + borderSize; y += brickH) {
                    const offset = (Math.floor((y - c.floorY) / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        const brickX = x + offset;
                        if (brickX < c.width) {
                            r.ctx.fillStyle = colours.white;
                            r.ctx.fillRect(brickX, y, brickW - 1, brickH - 1);
                        }
                    }
                }
                
                // Left border
                for (let y = borderSize; y < c.floorY; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < borderSize; x += brickW) {
                        const brickX = x + offset;
                        if (brickX < borderSize) {
                            r.ctx.fillStyle = colours.white;
                            r.ctx.fillRect(brickX, y, Math.min(brickW - 1, borderSize - brickX), brickH - 1);
                        }
                    }
                }
                
                // Right border
                for (let y = borderSize; y < c.floorY; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = c.width - borderSize; x < c.width; x += brickW) {
                        const brickX = x + offset;
                        r.ctx.fillStyle = colours.white;
                        r.ctx.fillRect(brickX, y, brickW - 1, brickH - 1);
                    }
                }
            },
            
            // Draw wavy/zigzag harpoon (authentic Spectrum Pang style)
            drawWavyHarpoon(r, h, colour, c) {
                const ctx = r.ctx;
                ctx.fillStyle = colour;
                
                // Zigzag pattern parameters
                const amplitude = 2;  // How far left/right the zigzag goes
                const period = 6;     // Vertical distance per zigzag cycle
                
                // Draw from bottom (player) to top (harpoon tip)
                for (let y = h.yBottom; y >= h.yTop; y -= 2) {
                    // Calculate x offset for zigzag
                    const phase = ((h.yBottom - y) / period) * Math.PI * 2;
                    const xOffset = Math.sin(phase) * amplitude;
                    
                    // Draw 2x2 pixel block for each segment
                    ctx.fillRect(Math.floor(h.x + xOffset) - 1, y, 2, 2);
                }
                
                // Draw harpoon head (small triangle/point at top)
                ctx.fillRect(h.x - 2, h.yTop - 2, 4, 4);
                ctx.fillRect(h.x - 1, h.yTop - 4, 2, 2);
            },
            
            // Draw outlined ball with dithered interior (authentic Spectrum Pang style)
            drawSpectrumBall(r, ball, colours) {
                const ctx = r.ctx;
                const { x, y, radius } = ball;
                const white = colours.brightWhite;
                
                // Draw outer circle outline (1-2 pixel white ring)
                ctx.strokeStyle = white;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw inner dithered fill using checkerboard pattern
                // This creates the "bubble" effect seen in authentic Spectrum Pang
                for (let py = y - radius + 1; py < y + radius - 1; py++) {
                    for (let px = x - radius + 1; px < x + radius - 1; px++) {
                        const dx = px - x;
                        const dy = py - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only fill inside the circle (with margin for outline)
                        if (dist < radius - 1.5) {
                            // Checkerboard dither pattern (50% density)
                            if ((Math.floor(px) + Math.floor(py)) % 2 === 0) {
                                ctx.fillStyle = white;
                                ctx.fillRect(Math.floor(px), Math.floor(py), 1, 1);
                            }
                        }
                    }
                }
                
                // Draw highlight in upper-left quadrant (solid white area)
                const highlightRadius = radius * 0.3;
                const highlightX = x - radius * 0.35;
                const highlightY = y - radius * 0.35;
                
                ctx.fillStyle = white;
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, highlightRadius, 0, Math.PI * 2);
                ctx.fill();
            },
            
            // Draw Spectrum player character (based on screenshot reference)
            // Original Spectrum Pang player is approximately 16x24 pixels
            // - Hat/helmet
            // - Body holding a weapon
            // - Legs
            // Player faces forward when idle, left/right only when moving
            drawSpectrumPlayer(r, p, colour, c) {
                const ctx = r.ctx;
                ctx.fillStyle = colour;
                
                const x = Math.floor(p.x);
                // Position sprite based on player's y position
                // p.y is the player's bottom position (feet level)
                const spriteHeight = 21;  // Our sprite is 21 rows tall
                // Draw sprite so the bottom row is at p.y
                const baseY = Math.floor(p.y - spriteHeight + p.bobOffset);
                
                // Animation frame for walking (2-frame toggle)
                const walkFrame = p.isWalking ? Math.floor(p.walkTimer * 4) % 2 : 0;
                
                // Pixel art sprite data - each row is a line of pixels
                // 1 = filled pixel, space = empty
                // Based on the original Spectrum Pang screenshot (~16x24 pixels)
                
                if (p.facing === 0) {
                    // FORWARD/BACK VIEW (idle or shooting) - symmetrical
                    // 16 pixels wide, 24 tall
                    const sprite = [
                        "     1111     ",  // Hat top
                        "    111111    ",  // Hat
                        "   11111111   ",  // Hat brim
                        "   11111111   ",  // Head top
                        "   11111111   ",  // Head
                        "   11111111   ",  // Head bottom
                        "    111111    ",  // Neck
                        "  1111111111  ",  // Shoulders wide
                        " 111111111111 ",  // Arms out
                        "  1111111111  ",  // Upper body
                        "  1111111111  ",  // Body
                        "   11111111   ",  // Mid body
                        "   11111111   ",  // Lower body
                        "   11111111   ",  // Waist
                        "    111111    ",  // Hips
                        "    11  11    ",  // Upper legs
                        "    11  11    ",  // Legs
                        "    11  11    ",  // Legs
                        "   111  111   ",  // Lower legs
                        "   111  111   ",  // Ankles
                        "  1111  1111  ",  // Feet
                    ];
                    this.drawPixelSprite(ctx, sprite, x, baseY, colour);
                } else {
                    // SIDE VIEW (walking left or right)
                    // Sprite is drawn facing LEFT by default, flip when facing RIGHT
                    const flip = p.facing > 0;
                    
                    // Two frames of walking animation - 14 pixels wide, 24 tall
                    let sprite;
                    if (walkFrame === 0) {
                        sprite = [
                            "    1111    ",  // Hat top
                            "   111111   ",  // Hat
                            "  11111111  ",  // Hat brim
                            "  1111111   ",  // Head
                            "  1111111   ",  // Head
                            "  1111111   ",  // Head
                            "   11111    ",  // Neck
                            "  1111111   ",  // Shoulders
                            " 111111111  ",  // Arms/body
                            "  11111111  ",  // Upper body
                            "  1111111   ",  // Body
                            "   111111   ",  // Mid body
                            "   111111   ",  // Lower body
                            "   11111    ",  // Waist
                            "    1111    ",  // Hips
                            "    1111    ",  // Upper leg
                            "    1111    ",  // Leg
                            "    1111    ",  // Leg
                            "    1111    ",  // Lower leg
                            "    1111    ",  // Ankle
                            "   11111    ",  // Foot
                        ];
                    } else {
                        sprite = [
                            "    1111    ",  // Hat top
                            "   111111   ",  // Hat
                            "  11111111  ",  // Hat brim
                            "  1111111   ",  // Head
                            "  1111111   ",  // Head
                            "  1111111   ",  // Head
                            "   11111    ",  // Neck
                            "  1111111   ",  // Shoulders
                            " 111111111  ",  // Arms/body
                            "  11111111  ",  // Upper body
                            "  1111111   ",  // Body
                            "   111111   ",  // Mid body
                            "   111111   ",  // Lower body
                            "   11111    ",  // Waist
                            "   11 11    ",  // Hips/legs apart
                            "  11   11   ",  // Upper legs apart
                            "  11   11   ",  // Legs
                            " 11     11  ",  // Legs apart
                            " 11     11  ",  // Lower legs
                            "111     111 ",  // Ankles
                            "111     111 ",  // Feet apart
                        ];
                    }
                    this.drawPixelSprite(ctx, sprite, x, baseY, colour, flip);
                }
            },
            
            // Helper to draw pixel art sprite from string array
            drawPixelSprite(ctx, sprite, centerX, topY, colour, flipH = false) {
                ctx.fillStyle = colour;
                const spriteWidth = sprite[0].length;
                const startX = centerX - Math.floor(spriteWidth / 2);
                
                for (let row = 0; row < sprite.length; row++) {
                    const line = sprite[row];
                    for (let col = 0; col < line.length; col++) {
                        if (line[col] === '1') {
                            const px = flipH ? (startX + spriteWidth - 1 - col) : (startX + col);
                            ctx.fillRect(px, topY + row, 1, 1);
                        }
                    }
                }
            },
            
            // =================================================================
            // 8-BIT PLUS (GX4000) BACKGROUND RENDERING
            // Rich, colorful Mt. Fuji scene based on authentic GX4000 Pang
            // =================================================================
            drawPlusBackground(r, c, colours) {
                const ctx = r.ctx;
                const left = c.playfieldLeft;
                const top = c.playfieldTop;
                const width = c.playfieldWidth;
                const height = c.playfieldHeight;
                
                // === SKY GRADIENT (top 40% of playfield) ===
                const skyHeight = height * 0.40;
                const skyBands = [
                    { y: 0, h: 0.3, color: colours.skyLight },
                    { y: 0.3, h: 0.4, color: colours.skyMedium },
                    { y: 0.7, h: 0.3, color: colours.skyDark }
                ];
                for (const band of skyBands) {
                    ctx.fillStyle = band.color;
                    ctx.fillRect(left, top + skyHeight * band.y, width, skyHeight * band.h + 1);
                }
                
                // === MT. FUJI (centered, snow-capped) ===
                const mtTop = top + skyHeight * 0.1;
                const mtBase = top + skyHeight * 0.95;
                const mtCenterX = left + width * 0.55;
                const mtWidth = width * 0.5;
                
                // Main mountain body (grey-purple)
                ctx.fillStyle = colours.mountainMedium;
                ctx.beginPath();
                ctx.moveTo(mtCenterX, mtTop);
                ctx.lineTo(mtCenterX - mtWidth * 0.5, mtBase);
                ctx.lineTo(mtCenterX + mtWidth * 0.5, mtBase);
                ctx.closePath();
                ctx.fill();
                
                // Mountain shadow (left side)
                ctx.fillStyle = colours.mountainDark;
                ctx.beginPath();
                ctx.moveTo(mtCenterX, mtTop);
                ctx.lineTo(mtCenterX - mtWidth * 0.5, mtBase);
                ctx.lineTo(mtCenterX - mtWidth * 0.15, mtBase);
                ctx.lineTo(mtCenterX, mtTop + (mtBase - mtTop) * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Snow cap (white, top portion)
                ctx.fillStyle = colours.mountainWhite;
                ctx.beginPath();
                ctx.moveTo(mtCenterX, mtTop);
                ctx.lineTo(mtCenterX - mtWidth * 0.18, mtTop + (mtBase - mtTop) * 0.25);
                ctx.lineTo(mtCenterX + mtWidth * 0.18, mtTop + (mtBase - mtTop) * 0.25);
                ctx.closePath();
                ctx.fill();
                
                // Snow patches (lighter areas)
                ctx.fillStyle = colours.mountainLight;
                ctx.beginPath();
                ctx.moveTo(mtCenterX - mtWidth * 0.1, mtTop + (mtBase - mtTop) * 0.2);
                ctx.lineTo(mtCenterX - mtWidth * 0.25, mtTop + (mtBase - mtTop) * 0.4);
                ctx.lineTo(mtCenterX - mtWidth * 0.05, mtTop + (mtBase - mtTop) * 0.35);
                ctx.closePath();
                ctx.fill();
                
                // === ATMOSPHERIC MIST LAYERS (middle section) ===
                const mistTop = top + skyHeight;
                const mistHeight = height * 0.25;
                
                // Multiple horizontal mist bands
                const mistBands = [
                    { y: 0, h: 0.2, color: colours.mistLight },
                    { y: 0.15, h: 0.25, color: colours.mistMedium },
                    { y: 0.35, h: 0.3, color: colours.mistDark },
                    { y: 0.6, h: 0.4, color: colours.groundLight }
                ];
                for (const band of mistBands) {
                    ctx.fillStyle = band.color;
                    ctx.fillRect(left, mistTop + mistHeight * band.y, width, mistHeight * band.h + 1);
                }
                
                // === GROUND/VEGETATION LAYER (bottom section) ===
                const groundTop = mistTop + mistHeight;
                const groundHeight = height - skyHeight - mistHeight;
                
                // Base ground color
                ctx.fillStyle = colours.groundMedium;
                ctx.fillRect(left, groundTop, width, groundHeight);
                
                // Darker ground at bottom
                ctx.fillStyle = colours.groundDark;
                ctx.fillRect(left, groundTop + groundHeight * 0.6, width, groundHeight * 0.4);
                
                // === FOREST SILHOUETTES ===
                // Left forest cluster
                this.drawTreeSilhouette(ctx, left + width * 0.05, groundTop + groundHeight * 0.3, 20, 35, colours.forestDark);
                this.drawTreeSilhouette(ctx, left + width * 0.12, groundTop + groundHeight * 0.25, 25, 40, colours.forestMedium);
                this.drawTreeSilhouette(ctx, left + width * 0.08, groundTop + groundHeight * 0.35, 18, 30, colours.forestDark);
                
                // Right forest cluster
                this.drawTreeSilhouette(ctx, left + width * 0.75, groundTop + groundHeight * 0.2, 22, 45, colours.forestDark);
                this.drawTreeSilhouette(ctx, left + width * 0.82, groundTop + groundHeight * 0.3, 20, 35, colours.forestMedium);
                this.drawTreeSilhouette(ctx, left + width * 0.88, groundTop + groundHeight * 0.25, 18, 40, colours.forestDark);
                
                // Scattered smaller trees
                this.drawTreeSilhouette(ctx, left + width * 0.35, groundTop + groundHeight * 0.4, 12, 25, colours.forestMedium);
                this.drawTreeSilhouette(ctx, left + width * 0.55, groundTop + groundHeight * 0.45, 10, 20, colours.forestDark);
                
                // === GRASS TUFTS (foreground detail) ===
                ctx.fillStyle = colours.grassGreen;
                for (let i = 0; i < 15; i++) {
                    const gx = left + (width * 0.1) + (width * 0.8 * i / 15);
                    const gy = groundTop + groundHeight * 0.7 + Math.random() * groundHeight * 0.2;
                    ctx.fillRect(gx, gy, 3, 5);
                    ctx.fillRect(gx + 2, gy - 2, 2, 4);
                }
            },
            
            // Draw a simple tree silhouette
            drawTreeSilhouette(ctx, x, y, width, height, color) {
                ctx.fillStyle = color;
                // Trunk
                ctx.fillRect(x + width * 0.4, y + height * 0.6, width * 0.2, height * 0.4);
                // Foliage (triangular)
                ctx.beginPath();
                ctx.moveTo(x + width * 0.5, y);
                ctx.lineTo(x, y + height * 0.7);
                ctx.lineTo(x + width, y + height * 0.7);
                ctx.closePath();
                ctx.fill();
            },
            
            // =================================================================
            // CPC CLASSIC BACKGROUND (Per CPCtelera: Mode 0, 27 colors)
            // Simpler than GX4000: fewer colors, flat fills, minimal dithering
            // "CPC looks best when it's clean, not busy"
            // =================================================================
            drawCPCBackground(r, c, colours) {
                const ctx = r.ctx;
                const left = c.playfieldLeft;
                const top = c.playfieldTop;
                const width = c.playfieldWidth;
                const height = c.playfieldHeight;
                
                // Mode 0 pixel width (2:1 aspect)
                const PX = 2;
                
                // === SKY - Single flat color (CPU-friendly) ===
                ctx.fillStyle = colours.skyBlue;
                ctx.fillRect(left, top, width, height * 0.35);
                
                // === MOUNTAIN - Simple blocky shape (fewer cycles than GX4000) ===
                const mtY = top + height * 0.10;
                const mtBaseY = top + height * 0.35;
                const mtPeakX = left + width * 0.5;
                
                // Mountain body - flat grey (single color, no gradient)
                ctx.fillStyle = colours.white;  // CPC "white" is actually grey #808080
                ctx.beginPath();
                ctx.moveTo(mtPeakX, mtY);
                ctx.lineTo(left + width * 0.15, mtBaseY);
                ctx.lineTo(left + width * 0.85, mtBaseY);
                ctx.closePath();
                ctx.fill();
                
                // Snow cap - smaller, simpler than GX4000
                ctx.fillStyle = colours.brightWhite;
                ctx.beginPath();
                ctx.moveTo(mtPeakX, mtY);
                ctx.lineTo(mtPeakX - width * 0.10, mtY + height * 0.08);
                ctx.lineTo(mtPeakX + width * 0.10, mtY + height * 0.08);
                ctx.closePath();
                ctx.fill();
                
                // === GROUND - Simple horizontal bands (fewer than GX4000) ===
                const groundY = top + height * 0.35;
                
                // Just 3 bands (vs GX4000's 5+)
                ctx.fillStyle = colours.green;
                ctx.fillRect(left, groundY, width, height * 0.25);
                
                ctx.fillStyle = colours.brightGreen;
                ctx.fillRect(left, groundY + height * 0.25, width, height * 0.20);
                
                ctx.fillStyle = colours.lime;
                ctx.fillRect(left, groundY + height * 0.45, width, height * 0.20);
                
                // === SIMPLE TREE (much simpler than GX4000) ===
                // Just a trunk and rectangular foliage
                ctx.fillStyle = colours.red;  // Dark brown from 27-color palette
                const treeX = left + width * 0.80;
                ctx.fillRect(treeX, groundY + height * 0.15, PX, 15);
                
                // Foliage - simple rectangles (not the detailed shape)
                ctx.fillStyle = colours.green;
                ctx.fillRect(treeX - 4, groundY + height * 0.05, 10, 8);
                ctx.fillRect(treeX - 2, groundY + height * 0.12, 6, 4);
            },
            
            // =================================================================
            // CPC PLAYER RENDERING (simpler than GX4000, single color)
            // Software sprite = expensive, so keep it simple
            // =================================================================
            drawCPCPlayer(r, p, colours, c) {
                const ctx = r.ctx;
                const x = Math.floor(p.x);
                const spriteHeight = 16;
                const baseY = Math.floor(p.y - spriteHeight + p.bobOffset);
                
                const walkFrame = p.isWalking ? Math.floor(p.walkTimer * 4) % 2 : 0;
                
                // CPC player is simpler - fewer color detail than GX4000
                // Just 2-3 colors: outline, body, face
                
                // Body (single color - cyan)
                ctx.fillStyle = colours.brightCyan;
                ctx.fillRect(x - 3, baseY, 6, 4);      // Head
                ctx.fillRect(x - 4, baseY + 4, 8, 6);  // Body
                
                // Legs (same color)
                if (walkFrame === 0) {
                    ctx.fillRect(x - 2, baseY + 10, 2, 5);
                    ctx.fillRect(x, baseY + 10, 2, 5);
                } else {
                    ctx.fillRect(x - 3, baseY + 10, 2, 5);
                    ctx.fillRect(x + 1, baseY + 10, 2, 5);
                }
                
                // Face (just 2x2 for skin - minimal detail)
                ctx.fillStyle = colours.pastelYellow;
                ctx.fillRect(x - 1, baseY + 1, 2, 2);
            },
            
            // =================================================================
            // CPC BALL RENDERING (simpler than GX4000)
            // Per CPCtelera: prefer flat fills, avoid gradients
            // =================================================================
            drawCPCBall(r, ball, colours) {
                const ctx = r.ctx;
                const { x, y, radius } = ball;
                const cx = Math.floor(x);
                const cy = Math.floor(y);
                const rad = Math.floor(radius);
                
                // CPC ball: single solid color (no gradient bands like GX4000)
                // Pick color based on size
                let color;
                if (ball.size === 'large') {
                    color = colours.brightRed;
                } else if (ball.size === 'medium') {
                    color = colours.orange;
                } else {
                    color = colours.brightYellow;
                }
                
                // Draw as horizontal scanlines (Mode 0 style)
                ctx.fillStyle = color;
                for (let py = -rad; py <= rad; py++) {
                    const halfWidth = Math.floor(Math.sqrt(rad * rad - py * py));
                    if (halfWidth > 0) {
                        ctx.fillRect(cx - halfWidth, cy + py, halfWidth * 2, 1);
                    }
                }
                
                // Simple 1px highlight (not the fancy outline of GX4000)
                ctx.fillStyle = colours.brightWhite;
                ctx.fillRect(cx - Math.floor(rad * 0.3), cy - Math.floor(rad * 0.3), 2, 2);
            },
            
            // =================================================================
            // CPC HARPOON (simpler zigzag than GX4000)
            // =================================================================
            drawCPCWavyHarpoon(r, h, colours, c) {
                const ctx = r.ctx;
                
                // Simpler zigzag - fewer segments
                const amplitude = 1;
                const period = 4;  // Longer period = fewer zigzags = less CPU
                
                ctx.fillStyle = colours.brightYellow;
                
                for (let y = h.yBottom; y >= h.yTop; y -= 3) {
                    const segment = Math.floor((h.yBottom - y) / period);
                    const xOffset = (segment % 2 === 0) ? amplitude : -amplitude;
                    ctx.fillRect(Math.floor(h.x + xOffset), y, 1, 4);
                }
                
                // Simple arrow head
                ctx.fillRect(h.x - 1, h.yTop - 2, 3, 2);
            },
            
            // =================================================================
            // CPC BRICK BORDER (simpler than GX4000's purple)
            // Uses blue bricks (from 27-color palette)
            // =================================================================
            drawCPCBrickBorder(r, c, colours) {
                const ctx = r.ctx;
                const brickW = 4;
                const brickH = 3;
                const borderSize = c.borderSize;
                
                // Simple 2-color bricks (no 3D shading like GX4000)
                const drawBrick = (x, y, w, h) => {
                    ctx.fillStyle = colours.blue;
                    ctx.fillRect(x, y, w, h);
                    // Just a highlight line (1 color, not 3)
                    ctx.fillStyle = colours.brightBlue;
                    ctx.fillRect(x, y, w, 1);
                };
                
                // Top border
                for (let y = 0; y < borderSize; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        drawBrick(x + offset, y, brickW - 1, brickH - 1);
                    }
                }
                
                // Bottom border
                for (let y = c.floorY; y < c.floorY + borderSize; y += brickH) {
                    const offset = (Math.floor((y - c.floorY) / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        drawBrick(x + offset, y, brickW - 1, brickH - 1);
                    }
                }
                
                // Side borders
                for (let y = borderSize; y < c.floorY; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < borderSize; x += brickW) {
                        drawBrick(x + offset, y, brickW - 1, brickH - 1);
                    }
                    for (let x = c.width - borderSize; x < c.width; x += brickW) {
                        drawBrick(x + offset, y, brickW - 1, brickH - 1);
                    }
                }
            },
            
            // =================================================================
            // 16-BIT BACKGROUND (rich colors, smooth gradients)
            // =================================================================
            draw16BitBackground(r, c, colours) {
                const ctx = r.ctx;
                const left = c.playfieldLeft;
                const top = c.playfieldTop;
                const width = c.playfieldWidth;
                const height = c.playfieldHeight;
                
                // Sky gradient
                ctx.fillStyle = colours.skyBlue;
                ctx.fillRect(left, top, width, height * 0.5);
                
                // Ground
                ctx.fillStyle = colours.groundBrown;
                ctx.fillRect(left, top + height * 0.5, width, height * 0.5);
            },
            
            // =================================================================
            // PLUS MODE BALL RENDERING (colorful gradient ball)
            // =================================================================
            drawPlusBall(r, ball, colours) {
                const ctx = r.ctx;
                const { x, y, radius } = ball;
                
                // Main ball body (red)
                ctx.fillStyle = colours.ballRed;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Dark shadow (bottom-right)
                ctx.fillStyle = colours.ballDark;
                ctx.beginPath();
                ctx.arc(x + radius * 0.2, y + radius * 0.2, radius * 0.85, 0, Math.PI * 2);
                ctx.fill();
                
                // Main body again (over shadow)
                ctx.fillStyle = colours.ballRed;
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.9, 0, Math.PI * 2);
                ctx.fill();
                
                // Orange mid-tone (gradient effect)
                ctx.fillStyle = colours.ballOrange;
                ctx.beginPath();
                ctx.arc(x - radius * 0.15, y - radius * 0.15, radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Yellow highlight (top-left)
                ctx.fillStyle = colours.ballYellow;
                ctx.beginPath();
                ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // White specular highlight
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(x - radius * 0.35, y - radius * 0.35, radius * 0.15, 0, Math.PI * 2);
                ctx.fill();
            },
            
            // =================================================================
            // PLUS MODE WAVY HARPOON (cyan/white chain pattern)
            // Based on authentic GX4000 Pang screenshot
            // =================================================================
            drawPlusWavyHarpoon(r, h, colours, c) {
                const ctx = r.ctx;
                
                // Zigzag pattern parameters - slightly wider for Plus mode
                const amplitude = 3;  // How far left/right the zigzag goes
                const period = 5;     // Vertical distance per zigzag cycle
                
                // Draw from bottom (floor) to top (harpoon tip)
                // Alternate between white and cyan for chain effect
                let colorToggle = 0;
                for (let y = h.yBottom; y >= h.yTop; y -= 2) {
                    // Calculate x offset for zigzag
                    const phase = ((h.yBottom - y) / period) * Math.PI * 2;
                    const xOffset = Math.sin(phase) * amplitude;
                    
                    // Alternate colors for chain link effect
                    ctx.fillStyle = (colorToggle % 2 === 0) ? colours.harpoonWhite : colours.harpoonCyan;
                    colorToggle++;
                    
                    // Draw 2x2 pixel block for each segment
                    ctx.fillRect(Math.floor(h.x + xOffset) - 1, y, 3, 3);
                }
                
                // Draw harpoon head (arrow point at top) - white
                ctx.fillStyle = colours.harpoonWhite;
                ctx.fillRect(h.x - 3, h.yTop - 2, 6, 4);
                ctx.fillRect(h.x - 2, h.yTop - 4, 4, 2);
                ctx.fillRect(h.x - 1, h.yTop - 6, 2, 2);
            },
            
            // =================================================================
            // PLUS MODE PLAYER RENDERING (colorful detailed sprite)
            // =================================================================
            drawPlusPlayer(r, p, colours, c) {
                const ctx = r.ctx;
                const x = Math.floor(p.x);
                const spriteHeight = 24;
                const baseY = Math.floor(p.y - spriteHeight + p.bobOffset);
                
                const walkFrame = p.isWalking ? Math.floor(p.walkTimer * 4) % 2 : 0;
                
                // Draw multi-colored player sprite
                // Hat (brown)
                ctx.fillStyle = colours.hairBrown;
                if (p.facing === 0) {
                    // Forward facing
                    ctx.fillRect(x - 4, baseY, 8, 3);
                    ctx.fillRect(x - 5, baseY + 3, 10, 2);
                } else {
                    // Side facing
                    const flip = p.facing > 0 ? 1 : -1;
                    ctx.fillRect(x - 3 * flip, baseY, 6, 3);
                    ctx.fillRect(x - 4 * flip, baseY + 3, 8, 2);
                }
                
                // Head (skin tone)
                ctx.fillStyle = colours.skinTone;
                ctx.fillRect(x - 3, baseY + 5, 6, 5);
                
                // Body (blue clothing)
                ctx.fillStyle = colours.clothBlue;
                ctx.fillRect(x - 4, baseY + 10, 8, 6);
                
                // Arms
                ctx.fillStyle = colours.clothLight;
                if (p.facing === 0) {
                    ctx.fillRect(x - 6, baseY + 10, 2, 5);
                    ctx.fillRect(x + 4, baseY + 10, 2, 5);
                } else {
                    const flip = p.facing > 0 ? 1 : -1;
                    ctx.fillRect(x + 4 * flip, baseY + 10, 2, 5);
                }
                
                // Legs
                ctx.fillStyle = colours.clothBlue;
                if (p.facing === 0 || walkFrame === 0) {
                    ctx.fillRect(x - 3, baseY + 16, 2, 6);
                    ctx.fillRect(x + 1, baseY + 16, 2, 6);
                } else {
                    // Walking animation - legs apart
                    ctx.fillRect(x - 4, baseY + 16, 2, 6);
                    ctx.fillRect(x + 2, baseY + 16, 2, 6);
                }
                
                // Feet (brown)
                ctx.fillStyle = colours.hairBrown;
                ctx.fillRect(x - 4, baseY + 22, 3, 2);
                ctx.fillRect(x + 1, baseY + 22, 3, 2);
            },
            
            // =================================================================
            // PLUS MODE BRICK BORDER
            // =================================================================
            drawPlusBrickBorder(r, c, colours) {
                const ctx = r.ctx;
                const brickW = 8;
                const brickH = 4;
                const borderSize = c.borderSize;
                
                // Draw all four borders with brick pattern
                for (let y = 0; y < borderSize; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        const brickX = x + offset;
                        if (brickX < c.width) {
                            ctx.fillStyle = colours.brickGrey;
                            ctx.fillRect(brickX, y, brickW - 1, brickH - 1);
                            ctx.fillStyle = colours.brickLight;
                            ctx.fillRect(brickX, y, brickW - 1, 1);
                            ctx.fillStyle = colours.brickDark;
                            ctx.fillRect(brickX, y + brickH - 2, brickW - 1, 1);
                        }
                    }
                }
                
                // Bottom border
                for (let y = c.floorY; y < c.floorY + borderSize; y += brickH) {
                    const offset = (Math.floor((y - c.floorY) / brickH) % 2) * (brickW / 2);
                    for (let x = 0; x < c.width; x += brickW) {
                        const brickX = x + offset;
                        if (brickX < c.width) {
                            ctx.fillStyle = colours.brickGrey;
                            ctx.fillRect(brickX, y, brickW - 1, brickH - 1);
                        }
                    }
                }
                
                // Side borders
                for (let y = borderSize; y < c.floorY; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    // Left
                    for (let x = 0; x < borderSize; x += brickW) {
                        ctx.fillStyle = colours.brickGrey;
                        ctx.fillRect(x + offset, y, brickW - 1, brickH - 1);
                    }
                    // Right
                    for (let x = c.width - borderSize; x < c.width; x += brickW) {
                        ctx.fillStyle = colours.brickGrey;
                        ctx.fillRect(x + offset, y, brickW - 1, brickH - 1);
                    }
                }
            },
            
            // =================================================================
            // GX4000 AUTHENTIC RENDERING METHODS
            // Per RULES_8BIT_GX4000_MODE.md: Mode 0, 16 colors, dithering
            // =================================================================
            
            // GX4000 Background - AUTHENTIC Mode 0 horizontal band style
            // Per CPCtelera: Mode 0 = 160x200, 16 colors, 2:1 pixel aspect
            // Based on real GX4000 Pang - very blocky, horizontal layers, minimal dithering
            drawGX4000Background(r, c, colours) {
                const ctx = r.ctx;
                const left = c.playfieldLeft;
                const top = c.playfieldTop;
                const width = c.playfieldWidth;
                const height = c.playfieldHeight;
                
                // Mode 0 pixels are 2x wide - we simulate this with 2-pixel wide blocks
                const PX = 2;  // Pixel width for Mode 0 simulation
                
                // === SKY - Single flat color (authentic Mode 0) ===
                ctx.fillStyle = colours.sky;
                ctx.fillRect(left, top, width, height * 0.35);
                
                // === MT. FUJI - Blocky triangle, no smooth curves ===
                const mtY = top + height * 0.08;
                const mtBaseY = top + height * 0.35;
                const mtPeakX = left + width * 0.5;
                
                // Mountain body - draw as horizontal lines (scanline style)
                ctx.fillStyle = colours.mountainGrey;
                for (let y = mtY; y < mtBaseY; y += 1) {
                    // Calculate width at this scanline
                    const progress = (y - mtY) / (mtBaseY - mtY);
                    const halfWidth = Math.floor(progress * width * 0.4);
                    ctx.fillRect(mtPeakX - halfWidth, y, halfWidth * 2, 1);
                }
                
                // Snow cap - blocky triangle
                ctx.fillStyle = colours.mountainWhite;
                const snowBase = mtY + height * 0.12;
                for (let y = mtY; y < snowBase; y += 1) {
                    const progress = (y - mtY) / (snowBase - mtY);
                    const halfWidth = Math.floor(progress * width * 0.15);
                    ctx.fillRect(mtPeakX - halfWidth, y, halfWidth * 2, 1);
                }
                
                // Dithered snow edge (2x2 checkerboard - authentic CPC dither)
                ctx.fillStyle = colours.mountainLight;
                for (let py = snowBase; py < snowBase + height * 0.06; py += PX) {
                    for (let px = mtPeakX - width * 0.18; px < mtPeakX + width * 0.18; px += PX) {
                        // 50% checkerboard dither
                        if ((Math.floor(px / PX) + Math.floor(py / PX)) % 2 === 0) {
                            ctx.fillRect(Math.floor(px), py, PX, PX);
                        }
                    }
                }
                
                // === ATMOSPHERIC HORIZONTAL BANDS (key GX4000 visual) ===
                // These distinctive bands are a hallmark of CPC Plus games
                const bandY = top + height * 0.32;
                const bandH = Math.max(2, Math.floor(height * 0.02));  // 2px minimum
                
                ctx.fillStyle = colours.atmosLight;
                ctx.fillRect(left, bandY, width, bandH);
                ctx.fillRect(left, bandY + bandH * 3, width, bandH);
                
                ctx.fillStyle = colours.atmosMedium;
                ctx.fillRect(left, bandY + bandH, width, bandH);
                ctx.fillRect(left, bandY + bandH * 4, width, bandH * 2);
                
                ctx.fillStyle = colours.atmosDark;
                ctx.fillRect(left, bandY + bandH * 2, width, bandH);
                
                // === GROUND AREA - Horizontal bands (Mode 0 style) ===
                const groundY = top + height * 0.50;
                
                ctx.fillStyle = colours.groundDark;
                ctx.fillRect(left, groundY, width, height * 0.08);
                
                ctx.fillStyle = colours.groundMedium;
                ctx.fillRect(left, groundY + height * 0.08, width, height * 0.06);
                
                // Vegetation bands
                ctx.fillStyle = colours.vegDark;
                ctx.fillRect(left, groundY + height * 0.14, width, height * 0.12);
                
                ctx.fillStyle = colours.vegMedium;
                ctx.fillRect(left, groundY + height * 0.26, width, height * 0.10);
                
                ctx.fillStyle = colours.vegLight;
                ctx.fillRect(left, groundY + height * 0.36, width, height * 0.14);
                
                // === BLOCKY TREES (Mode 0 pixel art) ===
                // Tree trunk (2px wide - single Mode 0 pixel)
                ctx.fillStyle = colours.treeDark;
                const treeX = left + width * 0.82;
                const treeY = groundY + height * 0.20;
                ctx.fillRect(treeX, treeY, PX, 20);
                
                // Tree foliage (blocky rectangles)
                ctx.fillRect(treeX - 4, treeY - 8, 10, 4);
                ctx.fillRect(treeX - 2, treeY - 4, 6, 4);
                ctx.fillRect(treeX - 6, treeY - 12, 14, 4);
                
                // Small vegetation tufts (2x2 pixel blocks)
                ctx.fillStyle = colours.vegDark;
                for (let i = 0; i < 6; i++) {
                    const tx = left + width * 0.15 + (width * 0.6 * i / 6);
                    const ty = groundY + height * 0.32 + (i % 3) * 3;
                    ctx.fillRect(Math.floor(tx), ty, PX * 2, PX);
                    ctx.fillRect(Math.floor(tx) + PX, ty - PX, PX, PX);
                }
            },
            
            // Draw dithered rectangle (2x2 Bayer pattern)
            drawDitheredRect(ctx, x, y, width, height, density) {
                const pattern = [
                    [0, 2],
                    [3, 1]
                ];
                const threshold = density * 4;
                
                for (let py = 0; py < height; py += 2) {
                    for (let px = 0; px < width; px += 2) {
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dx = 0; dx < 2; dx++) {
                                if (pattern[dy][dx] < threshold) {
                                    ctx.fillRect(x + px + dx, y + py + dy, 1, 1);
                                }
                            }
                        }
                    }
                }
            },
            
            // Draw blocky tree (GX4000 style - no smooth edges)
            drawBlockyTree(ctx, x, y, width, height) {
                // Trunk
                ctx.fillRect(x + width * 0.35, y + height * 0.6, width * 0.3, height * 0.4);
                // Foliage (blocky triangle approximation)
                const levels = 3;
                for (let i = 0; i < levels; i++) {
                    const levelY = y + (height * 0.6 * i / levels);
                    const levelW = width * (1 - i * 0.2);
                    const levelX = x + (width - levelW) / 2;
                    ctx.fillRect(levelX, levelY, levelW, height * 0.25);
                }
            },
            
            // GX4000 Ball - Mode 0 blocky style (authentic)
            // Per CPCtelera: Mode 0 pixels are 2x wide
            // GX4000 Pang balls have distinct horizontal color bands
            drawGX4000Ball(r, ball, colours) {
                const ctx = r.ctx;
                const { x, y, radius } = ball;
                const cx = Math.floor(x);
                const cy = Math.floor(y);
                const rad = Math.floor(radius);
                
                // Mode 0 pixel width (2x for wide pixels)
                const PX = 1;  // At 160x200 we're already at Mode 0 scale
                
                // Draw ball as horizontal color bands (authentic blocky look)
                // Each "scanline" of the ball gets one color
                for (let py = -rad; py <= rad; py++) {
                    const halfWidth = Math.floor(Math.sqrt(rad * rad - py * py));
                    
                    if (halfWidth > 0) {
                        // Color bands: yellow (top) -> orange (mid) -> red (bottom)
                        const normalizedY = (py + rad) / (rad * 2);
                        let color;
                        
                        if (normalizedY < 0.30) {
                            color = colours.ballYellow;  // Top 30%
                        } else if (normalizedY < 0.55) {
                            color = colours.ballOrange;  // Middle 25%
                        } else {
                            color = colours.ballRed;     // Bottom 45%
                        }
                        
                        ctx.fillStyle = color;
                        // Draw scanline (ensure minimum 2px width for visibility)
                        ctx.fillRect(cx - halfWidth, cy + py, Math.max(halfWidth * 2, 2), 1);
                    }
                }
                
                // Black outline - draw as pixels, not smooth arc
                ctx.fillStyle = colours.black;
                // Top and bottom edge pixels
                for (let px = -rad + 1; px < rad; px++) {
                    const edgeY = Math.floor(Math.sqrt(rad * rad - px * px));
                    ctx.fillRect(cx + px, cy - edgeY, 1, 1);  // Top
                    ctx.fillRect(cx + px, cy + edgeY, 1, 1);  // Bottom
                }
                // Left and right edge pixels
                for (let py = -rad + 1; py < rad; py++) {
                    const edgeX = Math.floor(Math.sqrt(rad * rad - py * py));
                    ctx.fillRect(cx - edgeX, cy + py, 1, 1);  // Left
                    ctx.fillRect(cx + edgeX, cy + py, 1, 1);  // Right
                }
                
                // White highlight (2x2 blocky pixel - Mode 0 style)
                ctx.fillStyle = colours.white;
                ctx.fillRect(cx - Math.floor(rad * 0.4), cy - Math.floor(rad * 0.4), 2, 2);
            },
            
            // GX4000 Player - Mode 0 blocky sprite (authentic)
            // Per CPCtelera: GX4000 sprites are 16x16 max, Mode 0 = 2:1 pixels
            // This creates a compact but detailed character
            drawGX4000Player(r, p, colours, c) {
                const ctx = r.ctx;
                const x = Math.floor(p.x);
                const spriteHeight = 16;  // Compact for Mode 0
                const baseY = Math.floor(p.y - spriteHeight + p.bobOffset);
                
                const walkFrame = p.isWalking ? Math.floor(p.walkTimer * 4) % 2 : 0;
                
                // All dimensions scaled for 160x200 Mode 0
                // Each "pixel" here represents a Mode 0 pixel (2x wide on real hardware)
                
                // Head/hat (brown) - 4px wide
                ctx.fillStyle = colours.hairBrown;
                ctx.fillRect(x - 2, baseY, 4, 2);      // Hat top
                ctx.fillRect(x - 3, baseY + 2, 6, 1);  // Hat brim
                
                // Face (skin) - 4px wide
                ctx.fillStyle = colours.skinTone;
                ctx.fillRect(x - 2, baseY + 3, 4, 3);
                
                // Body (beige/tan clothing) - 6px wide
                ctx.fillStyle = colours.clothBeige;
                ctx.fillRect(x - 3, baseY + 6, 6, 4);
                
                // Arms (darker)
                ctx.fillStyle = colours.clothDark;
                if (p.facing === 0) {
                    // Forward: arms at sides (1px each)
                    ctx.fillRect(x - 4, baseY + 6, 1, 3);
                    ctx.fillRect(x + 3, baseY + 6, 1, 3);
                } else {
                    // Side: one arm visible
                    const flip = p.facing > 0 ? 1 : -1;
                    ctx.fillRect(x + 3 * flip, baseY + 6, 1, 3);
                }
                
                // Legs (2px each)
                ctx.fillStyle = colours.clothDark;
                if (p.facing === 0 || walkFrame === 0) {
                    ctx.fillRect(x - 2, baseY + 10, 2, 4);
                    ctx.fillRect(x, baseY + 10, 2, 4);
                } else {
                    // Walking: legs apart
                    ctx.fillRect(x - 3, baseY + 10, 2, 4);
                    ctx.fillRect(x + 1, baseY + 10, 2, 4);
                }
                
                // Feet (1px tall, brown)
                ctx.fillStyle = colours.hairBrown;
                ctx.fillRect(x - 2, baseY + 14, 2, 2);
                ctx.fillRect(x, baseY + 14, 2, 2);
            },
            
            // GX4000 Wavy Harpoon - Mode 0 zigzag pattern
            // Per CPCtelera: Mode 0 uses 2:1 pixel aspect
            // The harpoon in GX4000 Pang is a tight zigzag rope
            drawGX4000WavyHarpoon(r, h, colours, c) {
                const ctx = r.ctx;
                
                // Mode 0 zigzag - tighter pattern for 160px width
                const amplitude = 1;  // 1px offset (appears as 2px on screen due to aspect)
                const period = 3;     // Shorter period for compact look
                
                ctx.fillStyle = colours.harpoonWhite;
                
                // Draw zigzag as connected pixel segments
                for (let y = h.yBottom; y >= h.yTop; y -= 2) {
                    const segment = Math.floor((h.yBottom - y) / period);
                    const xOffset = (segment % 2 === 0) ? amplitude : -amplitude;
                    
                    // Draw segment (1px wide in Mode 0 = 2px visual)
                    ctx.fillRect(Math.floor(h.x + xOffset), y, 1, 3);
                    
                    // Connect to next segment
                    if (y > h.yTop + 2) {
                        const nextOffset = ((segment + 1) % 2 === 0) ? amplitude : -amplitude;
                        const midX = Math.floor((h.x + xOffset + h.x + nextOffset) / 2);
                        ctx.fillRect(midX, y - 1, 1, 2);
                    }
                }
                
                // Arrow head (simple 3x3 point)
                ctx.fillRect(h.x - 1, h.yTop - 2, 3, 2);
                ctx.fillRect(h.x, h.yTop - 3, 1, 1);
            },
            
            // GX4000 Brick Border - PURPLE/LAVENDER (authentic!)
            // Per CPCtelera: This purple brick border is iconic to GX4000 Pang
            // Mode 0: smaller bricks due to 160px width
            drawGX4000BrickBorder(r, c, colours) {
                const ctx = r.ctx;
                // Smaller bricks for Mode 0 (160x200)
                const brickW = 4;  // 4px wide (appears 8px due to 2:1 aspect)
                const brickH = 3;  // 3px tall
                const borderSize = c.borderSize;
                
                // Helper to draw brick with 3D shading
                const drawBrick = (x, y, w, h) => {
                    // Main brick body (medium purple)
                    ctx.fillStyle = colours.borderMedium;
                    ctx.fillRect(x, y, w, h);
                    // Light edge (top/left) - 1px highlight
                    ctx.fillStyle = colours.borderLight;
                    ctx.fillRect(x, y, w, 1);
                    ctx.fillRect(x, y, 1, h);
                    // Dark edge (bottom/right) - 1px shadow
                    ctx.fillStyle = colours.borderDark;
                    ctx.fillRect(x, y + h - 1, w, 1);
                    ctx.fillRect(x + w - 1, y, 1, h);
                };
                
                // Top border
                for (let y = 0; y < borderSize; y += brickH) {
                    const offset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    for (let x = -brickW; x < c.width + brickW; x += brickW) {
                        if (x + offset >= 0 && x + offset < c.width) {
                            drawBrick(x + offset, y, brickW - 1, brickH - 1);
                        }
                    }
                }
                
                // Bottom border
                for (let y = c.floorY; y < c.floorY + borderSize; y += brickH) {
                    const offset = (Math.floor((y - c.floorY) / brickH) % 2) * (brickW / 2);
                    for (let x = -brickW; x < c.width + brickW; x += brickW) {
                        if (x + offset >= 0 && x + offset < c.width) {
                            drawBrick(x + offset, y, brickW - 1, brickH - 1);
                        }
                    }
                }
                
                // Side borders
                for (let y = borderSize; y < c.floorY; y += brickH) {
                    const rowOffset = (Math.floor(y / brickH) % 2) * (brickW / 2);
                    // Left border
                    for (let x = 0; x < borderSize; x += brickW) {
                        drawBrick(x + (rowOffset % brickW), y, brickW - 1, brickH - 1);
                    }
                    // Right border
                    for (let x = c.width - borderSize; x < c.width; x += brickW) {
                        drawBrick(x + (rowOffset % brickW), y, brickW - 1, brickH - 1);
                    }
                }
            }
        };
        
        // --------------------------------------------------------------------
        // GAMES REGISTRY
        // --------------------------------------------------------------------
        
        const GAMES = {
            pang: {
                id: 'pang',
                name: 'Pang',
                instance: PangGame,
                available: true
            },
            spaceinvaders: {
                id: 'spaceinvaders',
                name: 'Space Invaders',
                instance: null,
                available: false
            },
            breakout: {
                id: 'breakout',
                name: 'Breakout',
                instance: null,
                available: false
            }
        };
        
        // --------------------------------------------------------------------
        // UI CONTROLLER
        // --------------------------------------------------------------------
        
        let engine = null;
        let selectedMode = '16bit';
        let selectedGame = 'pang';
        
        const modeSelector = document.getElementById('mode-selector');
        const gameContainer = document.getElementById('game-container');
        const modeIndicator = document.getElementById('mode-indicator');
        const loading = document.getElementById('loading');
        const startBtn = document.getElementById('start-btn');
        const backBtn = document.getElementById('back-btn');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const gameButtons = document.querySelectorAll('.game-btn');
        
        // Game selection
        gameButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                // Ignore clicks on coming soon games
                if (btn.classList.contains('coming-soon')) return;
                
                gameButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedGame = btn.dataset.game;
            });
        });
        
        // Mode selection
        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                modeButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedMode = btn.dataset.mode;
            });
        });
        
        // Start game
        startBtn.addEventListener('click', async () => {
            const game = GAMES[selectedGame];
            if (!game || !game.available) {
                alert('This game is not available yet!');
                return;
            }
            
            loading.classList.add('active');
            startBtn.disabled = true;
            
            try {
                engine = new Engine('game');
                await engine.setMode(selectedMode);
                await engine.loadGame(game.instance);
                
                modeSelector.classList.add('hidden');
                gameContainer.classList.add('active');
                modeIndicator.textContent = `${game.name} | ${engine.mode.name} (${engine.mode.canvas.width}×${engine.mode.canvas.height})`;
                
                engine.start();
            } catch (e) {
                console.error('Failed to start:', e);
                alert('Failed to start game. Check console.');
            }
            
            loading.classList.remove('active');
            startBtn.disabled = false;
        });
        
        // Back to mode select
        backBtn.addEventListener('click', () => {
            if (engine) {
                engine.stop();
                engine = null;
            }
            gameContainer.classList.remove('active');
            modeSelector.classList.remove('hidden');
        });
        
        // Export to CPCtelera
        const exportBtn = document.getElementById('export-btn');
        
        // Update export button state based on mode
        function updateExportButton() {
            if (!engine || !engine.mode) {
                exportBtn.disabled = true;
                exportBtn.title = 'Start a game first';
                return;
            }
            
            const exportableModes = ['8bit-cpc', '8bit-gx4000'];
            if (exportableModes.includes(engine.mode.id)) {
                exportBtn.disabled = false;
                exportBtn.title = `Export ${engine.mode.id === '8bit-gx4000' ? '.CPR (GX4000)' : '.DSK (CPC)'} project`;
            } else {
                exportBtn.disabled = true;
                exportBtn.title = `Export only available for CPC/GX4000 modes`;
            }
        }
        
        exportBtn.addEventListener('click', async () => {
            if (!engine || !engine.mode) {
                alert('Start a game first!');
                return;
            }
            
            const exportableModes = ['8bit-cpc', '8bit-gx4000'];
            if (!exportableModes.includes(engine.mode.id)) {
                alert(`Export is only available for CPC and GX4000 modes.\nCurrent mode: ${engine.mode.name}`);
                return;
            }
            
            // Get game state if available
            const gameState = engine.game?.getState ? engine.game.getState() : {};
            
            // Generate project name
            const projectName = `pang_${engine.mode.id.replace('-', '_')}`;
            
            // Show export dialog
            const confirmMsg = `Export CPCtelera Project\n\n` +
                `Mode: ${engine.mode.name}\n` +
                `Target: ${engine.mode.id === '8bit-gx4000' ? 'GX4000 (.CPR)' : 'Amstrad CPC (.DSK)'}\n` +
                `Project: ${projectName}\n\n` +
                `This will download:\n` +
                `- src/main.c (game template)\n` +
                `- src/game_constants.h\n` +
                `- src/palette.h\n` +
                `- Makefile\n` +
                `- README.txt\n\n` +
                `Continue?`;
            
            if (confirm(confirmMsg)) {
                try {
                    exportBtn.disabled = true;
                    exportBtn.textContent = '⏳ EXPORTING...';
                    
                    await cpcExporter.downloadProject(engine.mode, gameState, projectName);
                    
                    alert(`Export complete!\n\nFiles downloaded. See README.txt for build instructions.\n\nRequires CPCtelera SDK to compile.`);
                } catch (e) {
                    console.error('Export failed:', e);
                    alert('Export failed. Check console for details.');
                } finally {
                    exportBtn.disabled = false;
                    exportBtn.textContent = '⬇ EXPORT CPCtelera';
                    updateExportButton();
                }
            }
        });
        
        // Update export button when game starts
        const originalStart = startBtn.onclick;
        startBtn.addEventListener('click', () => {
            setTimeout(updateExportButton, 100);
        });
    </script>
</body>
</html>
